---
title: "Apartment Rent Analysis"
output: pdf_document
date: "2022-12-14"
---

```{r, warning=FALSE, message=FALSE}
require(splines)
require(glmnet)
require(viridis)
require(nortest)
require(lmtest)
require(caret)
require(multcomp)
require(broom)
require(tidyverse)
require(mgcv)
require(genlasso)
require(foreach)
require(doParallel)
require(geojsonio)
require(sp)
require(spdep)
require(gratia)
require(visreg)
library(broom)
require(viridis)
require(gridExtra)
set.seed(93)
n.cores <- 10
cluster <- parallel::makeCluster(
  n.cores, 
  type = "FORK"
)
doParallel::registerDoParallel(cl = cluster)
```

# Preparations

The set of apartments with missing square footage filled in via regression from 
the previous stage is loaded. Then, all the categorical variables are converted 
to actual categorical types.


```{r}
apartment_full <- read.csv("full_sqft.csv")
apartment_selected <- apartment_full %>% select(-address, -city, -name, -state, -bath_count, -bed_count, -neighborhood)
apartment_selected <- apartment_selected %>% mutate(shopping.num = as.factor(shopping.num),
                                                    zip = as.character(zip),
                                                    count.pub.high = as.factor(count.pub.high), 
                                                    pub.elt.mid = as.factor(pub.elt.mid), 
                                                    priv.elt.mid = as.factor(priv.elt.mid),
                                                    priv.el.hi = as.factor(priv.el.hi),
                                                    priv.elt.mid.hi = as.factor(priv.elt.mid.hi),
                                                    air.level = as.factor(air.level),
                                                    base.num = as.factor(base.num),
                                                    busi.level = as.factor(busi.level),
                                                    has.covered = as.factor(has.covered),
                                                    has.garage = as.factor(has.garage),
                                                    has.lot = as.factor(has.lot),
                                                    has.street = as.factor(has.street),
                                                    pet.allowed = as.factor(pet.allowed),
                                                    traffic.level = as.factor(traffic.level),
                                                    has.parking = as.factor(has.parking),
                                                    has.pub.elementary = as.factor(has.pub.elementary),
                                                    has.priv.elementary = as.factor(has.priv.elementary),
                                                    has.pub.mid = as.factor(has.pub.mid),
                                                    has.cha.high = as.factor(has.cha.high),
                                                    has.priv.high = as.factor(has.priv.high),
                                                    has.cha.mid.high = as.factor(has.cha.mid.high),
                                                    has.priv.mid.high = as.factor(has.priv.mid.high),
                                                    has.pub.mid.high = as.factor(has.pub.mid.high),
                                                    priv.el.hi = as.factor(priv.el.hi),
                                                    cha.elt.mid.hi = as.factor(cha.elt.mid.hi),
                                                    priv.elt.mid.hi = as.factor(priv.elt.mid.hi),
                                                    sqft.regressed = as.factor(sqft.regressed))
```

## Identifying geo-spatial relations between the zip codes

The map of Chicago with zip codes are obtained from the website for the City 
of Chicago. Then, for each zip code, the neighboring zip codes are found, so that 
it would be possible to merge regions with similar effects on rent. Some zip codes 
seem to be split into multiple shapes when just looking at Chicago. Thus, the zips 
with multiple shapes are identified.

```{r}
zip.map <- geojson_read("zip.geojson",  what = "sp")
zip.nb <- poly2nb(zip.map)
zip.mat <- nb2mat(zip.nb, style="B")
zip_freq <- table(zip.map$zip)
duplicates <- names(zip_freq)[which(zip_freq > 1)]
```

Then, prior to getting the final adjacency matrix for zips, the apartment data 
is filtered so that only the apartments in Chicago proper are retained. Then, 
the reference level for zip is set to the one with the most number of apartments, 
so that the reference level actually correspond to a good baseline.

```{r}
apartment_selected <- apartment_selected %>% filter(zip %in% as.character(zip.map$zip))
apartment_selected_zipcount <- aggregate(rent ~ zip, apartment_selected, length)
colnames(apartment_selected_zipcount) <- c("zip", "count")
apartment_selected_zipcount <- apartment_selected_zipcount[order(apartment_selected_zipcount$count, decreasing = T), ]
contrast_zip <- as.character(apartment_selected_zipcount$zip[1])
```

Finally, the adjacency zip matrix is created. The neighboring zip regions for zips 
with duplicated shapes are combined into one. Then, the final matrix is ordered 
in the same fashion as the level of the zip categorical variables from the apartment.

```{r}
options(max.print = 1000000)
dup.zip.idx <- which(zip.map$zip %in% duplicates)
unique.zip.mat <- as.matrix(zip.mat)
distinct_zip_names <- zip.map$zip[-dup.zip.idx]
for(zip.code in duplicates) {
  duplicate_idx <- zip.map$zip == zip.code
  combined_neighbor_row <- apply(unique.zip.mat[duplicate_idx, ], MARGIN = 2, FUN = sum)
  combined_neighbor_row[combined_neighbor_row > 1] <- 1
  combined_neighbor_row <- combined_neighbor_row
  unique.zip.mat <- rbind(unique.zip.mat, combined_neighbor_row)
  unique.zip.mat <- cbind(unique.zip.mat, c(combined_neighbor_row, 0))
  distinct_zip_names <- c(distinct_zip_names, zip.code)
}
unique.zip.mat <- unique.zip.mat[-dup.zip.idx, -dup.zip.idx]
row.names(unique.zip.mat) <- distinct_zip_names
colnames(unique.zip.mat) <- distinct_zip_names

zip_factors <- as.factor(apartment_selected$zip)
zip_factors <- relevel(zip_factors, contrast_zip)
zip.order <- levels(zip_factors)
unique.zip.mat <- unique.zip.mat[zip.order, zip.order]
```

## Variable Selection and Transformations

The original dataset, which came from Apartments.com, had many variables that 
are generated by Apartments.com itself. Those variables include things like nearby 
schools, shopping centers etc. Since those variables are not really well defined, 
and is limited to Apartments.com, they are removed from the dataset. In the end, 
by considering how well defined a variable is, and how easy it is to get a value 
for the variable, the following variables are considered.

- zip: the Zip code
- baths: the number of bathrooms
- beds: the number of bedrooms
- sqft: the size of the apartment in square feet
- sqft.regressed: whether the square feet variable was missing
- has.covered: whether the apartment has covered parking
- has.garage: whether the apartment has parking garages
- has.lot: whether the apartment has uncovered parking lot
- has.street: whether the apartment has street parking

Out of those variables, only the square feet is treated as numerical variable.

```{r}
apartment_selected <- apartment_selected %>% 
  select(sqft, zip, baths, beds, sqft.regressed, has.covered, has.garage, 
         has.lot, has.street, rent) %>% mutate(zip = zip_factors, 
                                               baths = as.factor(baths),
                                               beds = as.factor(beds))

apartment_train <- apartment_selected
```

Since sqft is the only numerical variable, and it is important for the rent, 
transformations on sqft are examined. In the end, a log-log transform seem to 
work well in getting a more linear shape, with less heteroskdacity.

```{r, message=FALSE}
sqft.plt.1 <- ggplot(apartment_train, aes(x = sqft, y = rent)) + geom_point() + geom_smooth(method = "gam")
sqft.plt.2 <- ggplot(apartment_train, aes(x = log(sqft), y = log(rent))) + geom_point() + geom_smooth(method = "gam")
grid.arrange(sqft.plt.1, sqft.plt.2)
```

For the categorical variables, zip, beds, and baths have 

```{r}
fuse_aic <- function(lasso_path, std_resid) {
    N <- nrow(lasso_path$fit)
    y <- matrix(lasso_path$pathobjs$y, nrow = length(lasso_path$pathobjs$y), ncol = length(lasso_path$lambda), byrow = FALSE)
    error <- apply((y - lasso_path$fit)^2, 2, sum)
    adj.sigma <- N * std_resid^2
    adj.opt <- 2 * std_resid^2 * lasso_path$df
    return((error + adj.sigma + adj.opt) / N)
}

set_pen_mat <- function(mat, offset, M) {
  K <- nrow(mat)
  M[(1:K) + offset, (1:K) + offset] <- mat
  return(M)
}

sequential_pen_mat <- function(K, offset, M) {
  mat <- matrix(0, nrow = K, ncol = K)
  for(i in 2:K) {
    mat[i, i - 1] <- 1
    mat[i - 1, i] <- 1
  }
  return(set_pen_mat(mat, offset, M))
}

prep_lasso_mat <- function(apartment_df) {
  apartment_train.mat <- as.data.frame(model.matrix(rent ~ . + log(sqft) - sqft, apartment_df)[, -1])
  apartment_train.mat$rent <- apartment_df$rent
  max.logsqft <- max(apartment_train.mat$`log(sqft)`)
  min.logsqft <- min(apartment_train.mat$`log(sqft)`)
  qlogsqft <- (apartment_train.mat$`log(sqft)` - min.logsqft) / (max.logsqft - min.logsqft)
  apartment_train.mat$qlogsqft <- qlogsqft
  apartment_train.mat <- apartment_train.mat %>% select(-`log(sqft)`)
  full.mod.varrank <- lm(log(rent) ~ ., apartment_train.mat)
  M <- length(full.mod.varrank$coefficients)
  pen_mat <- matrix(0, nrow = M, ncol = M)

  apartment_train.mat <- as.data.frame(model.matrix(rent ~ . - sqft, apartment_df)) %>% mutate(rent = apartment_df$rent)
  zip_coefficients <- full.mod.varrank$coefficients[names(full.mod.varrank$coefficients)[grepl("zip", names(full.mod.varrank$coefficients), fixed = TRUE)]]
  apartment_train_lasso <- data.frame(intercept = apartment_train.mat[, 1])
  apartment_train_lasso <- cbind(apartment_train_lasso, apartment_train.mat[, names(zip_coefficients)])
  zip_numbers <- substring(names(zip_coefficients), 4)
  pen_mat <- set_pen_mat(unique.zip.mat[zip_numbers, zip_numbers], 1, pen_mat)

  beds_coefficients <- full.mod.varrank$coefficients[names(full.mod.varrank$coefficients)[grepl("beds", names(full.mod.varrank$coefficients), fixed = TRUE)]]
  pen_mat <- sequential_pen_mat(length(beds_coefficients), ncol(apartment_train_lasso), pen_mat)
  apartment_train_lasso <- cbind(apartment_train_lasso, apartment_train.mat[, names(beds_coefficients)])
  
  baths_coefficients <- full.mod.varrank$coefficients[names(full.mod.varrank$coefficients)[grepl("baths", names(full.mod.varrank$coefficients), fixed = TRUE)]]
  pen_mat <- sequential_pen_mat(length(baths_coefficients), ncol(apartment_train_lasso), pen_mat)
  apartment_train_lasso <- cbind(apartment_train_lasso, apartment_train.mat[, names(baths_coefficients)])

  lasso.colnames <- c("intercept", names(zip_coefficients), names(beds_coefficients), names(baths_coefficients))
  colnames(apartment_train_lasso) <- lasso.colnames
  lasso.unincl <- names(full.mod.varrank$coefficients)[!names(full.mod.varrank$coefficients) %in% colnames(apartment_train_lasso)]
  lasso.unincl <- lasso.unincl[-c(1, length(lasso.unincl))]

  apartment_train_lasso <- cbind(apartment_train_lasso, apartment_train.mat[, lasso.unincl])
  apartment_train_lasso$qlogsqft <- qlogsqft
  return(list(X = apartment_train_lasso, penalties = graph_from_adjacency_matrix(pen_mat, mode = "undirected", diag=FALSE)))
}
```


```{r}
select_penal_param <- function(apartment_df, max_gamma, n_gamma, sigma, crit = fuse_aic) {
  apartment_fuse_lasso <- prep_lasso_mat(apartment_df)
  gamma_grid <- seq(from = 0, to = max_gamma, length.out = n_gamma)
  best_aic <- Inf
  best_gamma <- 0
  best_lambda <- NULL

  fuse_aic <- function(lasso_path, std_resid) {
    N <- nrow(lasso_path$fit)
    y <- matrix(lasso_path$pathobjs$y, nrow = length(lasso_path$pathobjs$y), ncol = length(lasso_path$lambda), byrow = FALSE)
    error <- apply((y - lasso_path$fit)^2, 2, sum)
    adj.sigma <- N * std_resid^2
    adj.opt <- 2 * std_resid^2 * lasso_path$df
    return((error + adj.sigma + adj.opt) / N)
  }
  
  results <- foreach(
    gamma_param = gamma_grid,
    .combine = "c"
  ) %dopar% {
    gen_lasso_path <- genlasso::fusedlasso(y = log(apartment_df$rent), X = as.matrix(apartment_fuse_lasso$X), graph = apartment_fuse_lasso$penalties, 
                                             maxsteps = Inf, gamma = gamma_param)
    insample_aic <- crit(gen_lasso_path, sigma)
    current_best <- which(insample_aic == min(insample_aic))
    if(length(current_best) >= 2) {
      current_best <- current_best[1]
    }
    return(list(list(best_aic=insample_aic[current_best], best_idx=current_best, best_lambda = gen_lasso_path$lambda[current_best],  gamma=gamma_param)))
  }
  for(r in results) {
      if(r$best_aic <= best_aic) {
        best_gamma <- r$gamma
        best_aic <- r$best_aic 
        best_lambda <- r$best_lambda
      }
  }
  return(list(aic=best_aic, gamma=best_gamma, lambda=best_lambda))
}
```


```{r}
apartment_train <- apartment_train %>% mutate(beds = factor(beds, levels = sort(unique(beds)))) %>% mutate(baths = factor(baths, levels = sort(unique(baths))))
```


```{r}
combine_lasso_components <- function(matcher, lasso_betas, zero_level) {
  lasso_betas <- sort(lasso_betas)
  coef_names <- names(lasso_betas)
  coef_names_match <- coef_names[grepl(matcher, coef_names, fixed = TRUE)]
  betas_match <- lasso_betas[coef_names_match]
  betas_match <- sort(betas_match)
  combine_mat <- matrix(0, nrow = length(betas_match), ncol = length(betas_match))
  
  for(i in 2:length(betas_match)) {
    if(betas_match[i] - betas_match[i - 1] == 0) {
      combine_mat[i, i - 1] = 1
      combine_mat[i - 1, i] = 1
    }
  }
  combine_graph <- graph_from_adjacency_matrix(combine_mat, mode = "undirected", diag=FALSE)
  combine_components <- components(combine_graph, "weak")
  select_components <- which(combine_components$csize >= 2)
  result = list()
  zero_components <- c()
  zip_factors
  for(c in select_components) {
    component_parts <- names(betas_match[combine_components$membership == c])
    if(sum(abs(betas_match[component_parts])) != 0) {
      result[[paste0("C", c)]] <- component_parts
    }
  }
  
  zero_components <- c(names(betas_match[betas_match == 0]), zero_level)
  if(length(zero_components) > 1) {
    result[["C0"]] <- zero_components
  }
  
  return(result)
}

apartment_merged <- as.data.frame(apartment_train)
```


```{r}
consolidate_levels <- function(partitions, prefix_length, var, df) {
  zero_levels <- levels(df[[var]])[1]
  df <- df %>% mutate(!! var := as.character(.data[[var]]))
  for(p in names(partitions)) {
    var_level <- substring(partitions[[p]], prefix_length)
    df <- df %>% 
      mutate(!! var := case_when(.data[[var]] %in% var_level ~ p, TRUE ~ .data[[var]]))
  }
  df <- df %>% mutate(!! var := as.factor(.data[[var]]))
  if("C0" %in% names(partitions)) {
    df[[var]] <- relevel(df[[var]], "C0")
  } else {
    df[[var]] <- relevel(df[[var]], zero_levels)
  }
  return(df)
}

```


Since there will not be any more apartment from May of 2022, the model is fitted 
mostly to find the relationships between the variables. Thus, only cross validation 
well be performed. For cross validation, the dataset is 

```{r}
apartment_train_shuffled <- apartment_train[sample(1:nrow(apartment_train)), ]
apartment_folds <- groupKFold(1:nrow(apartment_train_shuffled), 10)
```

```{r}
cv_rmse <- data.frame()

for(indexes in apartment_folds) {
  training_df <- apartment_train[indexes, ]

  best_lasso <- select_penal_param(training_df, 1, 200, sd(full.mod.log.2$residuals))
  apartment_fuse_lasso <- prep_lasso_mat(training_df)
  gen_lasso_path <- genlasso::fusedlasso(y = log(training_df$rent), X = as.matrix(apartment_fuse_lasso$X), graph = apartment_fuse_lasso$penalties, 
                                             maxsteps = Inf, gamma = best_lasso$gamma)
  fuse_lasso_coef <- coef(gen_lasso_path, lambda = best_lasso$lambda)
  lasso_betas <- c(fuse_lasso_coef$beta)
  names(lasso_betas) <- colnames(apartment_fuse_lasso$X)
  apartment_merged <- as.data.frame(apartment_train)
  zip_partitions <- combine_lasso_components("zip", lasso_betas, paste0("zip", levels(apartment_merged$zip)[1]))
  baths_partitions <- combine_lasso_components("baths", lasso_betas, "baths1")
  beds_partitions <- combine_lasso_components("beds", lasso_betas, "beds0")
  apartment_merged <- consolidate_levels(zip_partitions, 4, "zip", apartment_merged)
  apartment_merged <- consolidate_levels(baths_partitions, 6, "baths", apartment_merged)
  apartment_merged <- consolidate_levels(beds_partitions, 5, "beds", apartment_merged)
  training_merged <- apartment_merged[indexes, ]
  test_df <- apartment_merged[-indexes, ]
  
  log.log.mod <- lm(log(rent) ~ log(sqft) + zip + baths + beds + sqft.regressed + has.covered + has.garage + has.lot + has.street, data = training_merged)
  untrans.gam <- gam(rent ~ s(sqft, k = 2001, m = 2) + zip + baths + beds + sqft.regressed + has.covered + has.garage + has.lot + has.street, data = training_merged, method = "REML")
  gam.mod.log <- gam(log(rent) ~ s(log(sqft), k = 2001, m = 2) + zip + baths + beds + sqft.regressed + has.covered + has.garage + has.lot + has.street, data = training_merged, method = "REML")
  
  log.log.pred <- exp(predict(log.log.mod, test_df))
  untrans.pred <- predict(untrans.gam, test_df)
  gam.log.pred <- exp(predict(gam.mod.log, test_df))
  
  log.log.pred.rmse <- sqrt(mean((test_df$rent - log.log.pred)^2))
  untrans.pred.rmse <- sqrt(mean((test_df$rent - untrans.pred)^2))
  gam.pred.rmse <- sqrt(mean((test_df$rent - gam.log.pred)^2))
  
  cv_rmse <- rbind(cv_rmse, c(log.log.pred.rmse, "log.log.lm"))
  cv_rmse <- rbind(cv_rmse, c(untrans.pred.rmse, "reg.gam"))
  cv_rmse <- rbind(cv_rmse, c(gam.pred.rmse, "log.gam"))
}

colnames(cv_rmse) <- c("RMSE", "Method")
cv_rmse$RMSE <- as.numeric(cv_rmse$RMSE)
head(cv_rmse)
```

```{r}
ggplot(cv_rmse, aes(x = Method, y = RMSE, fill = Method)) + geom_boxplot()
```

```{r}
aggregate(RMSE ~ Method, cv_rmse, mean)
```


```{r}
best_lasso <- select_penal_param(apartment_train, 1, 200, sd(full.mod.log.2$residuals))
apartment_fuse_lasso <- prep_lasso_mat(apartment_train)
gen_lasso_path <- genlasso::fusedlasso(y = log(apartment_train$rent), X = as.matrix(apartment_fuse_lasso$X), graph = apartment_fuse_lasso$penalties, 
                                             maxsteps = Inf, gamma = best_lasso$gamma)
fuse_lasso_coef <- coef(gen_lasso_path, lambda = best_lasso$lambda)
lasso_betas <- c(fuse_lasso_coef$beta)
names(lasso_betas) <- colnames(apartment_fuse_lasso$X)
apartment_merged <- as.data.frame(apartment_train)
zip_partitions <- combine_lasso_components("zip", lasso_betas, paste0("zip", levels(apartment_merged$zip)[1]))
baths_partitions <- combine_lasso_components("baths", lasso_betas, "baths1")
beds_partitions <- combine_lasso_components("beds", lasso_betas, "beds0")
apartment_merged <- consolidate_levels(zip_partitions, 4, "zip", apartment_merged)
apartment_merged <- consolidate_levels(baths_partitions, 6, "baths", apartment_merged)
apartment_merged <- consolidate_levels(beds_partitions, 5, "beds", apartment_merged)
zip_partitions
```

```{r}
gam.mod.log.2 <- gam(log(rent) ~ s(log(sqft), k = 2001, m = 2) + zip + baths + beds + sqft.regressed + has.covered + has.garage + has.lot + has.street, data = apartment_merged, method = "REML")
```


```{r}
gam.check(gam.mod.log.2)
summary(gam.mod.log.2)
```


```{r}
bptest(gam.mod.log.2)
```

```{r}
dwtest(gam.mod.log.2)
```
```{r}
lillie.test(gam.mod.log.2$residuals)
```


```{r}
get_effect <- function(l_rent) {
  return(exp(l_rent - coef(gam.mod.log.2)[1]))
}

visreg(gam.mod.log.2, "sqft", trans = get_effect, 
       ylab = "rent", cond=list(zip="60601", beds = "0", baths = "1", 
                                sqft.regressed = "False", has.covered = "False",
                                has.garage = "False", has.lot = "False", has.street = "False"))
```

```{r}
visreg(gam.mod.log.2, "sqft", trans = get_effect, 
       data = apartment_merged, ylab = "rent", xlim = c(200, 2500), 
       ylim = c(0, 4), cond=list(zip="60601", beds = "0", baths = "1", 
                                sqft.regressed = "False", has.covered = "False",
                                has.garage = "False", has.lot = "False", has.street = "False"))
```

```{r}
gam.mod.coef <- coef(gam.mod.log.2)
zip_coefs <- gam.mod.coef[grepl("zip", names(gam.mod.coef), fixed = TRUE)]
zip_coef_df <- data.frame()

for(n in names(zip_coefs)) {
  zipcode <- substring(n, 4)
  if(zipcode %in% names(zip_partitions)) {
    actual_codes <- substring(zip_partitions[[zipcode]], 4)
    for(code in actual_codes) {
      zip_coef_df <- rbind(zip_coef_df, c(code, zip_coefs[n]))
    }
  } else {
    zip_coef_df <- rbind(zip_coef_df, c(zipcode, zip_coefs[n]))
  }
}
if(!grepl("C0", levels(apartment_merged$zip)[1], fixed = T)) {
  zip_coef_df <- rbind(zip_coef_df, c(levels(apartment_merged$zip)[1], 0))
}

colnames(zip_coef_df) <- c("zip", "effect")
zip_coef_df$effect <- as.numeric(zip_coef_df$effect)
zip_id_df <- data.frame(id = zip.map$objectid, zip = zip.map$zip)
zip_coef_df <- merge(x = zip_id_df, y = zip_coef_df, by = "zip", all.x = TRUE)
zip.geo.df <- tidy(zip.map)
zip.geo.df <- merge(x = zip.geo.df, y = zip_coef_df, by = "id", all.x = TRUE)
zip.geo.df$effect <- exp(zip.geo.df$effect)
head(zip.geo.df)
```


```{r}
ggplot(data = zip.geo.df) +
  geom_polygon(aes( x = long, y = lat, group = group, fill=effect), color="white") +
  theme_void() + scale_fill_viridis() +
  coord_map() + ggtitle("Multiplicative Effect to Rent by Zip")
```

```{r}
confint.paragam <- function(mod, level = 0.95) {
  mod.s <- summary(mod)
  
  E <- data.frame(Estimate = mod.s$p.coeff) %>%
    mutate(Term = row.names(.)) %>%
    select(Term, Estimate)
  
  SE <- data.frame(SE = mod.s$se) %>%
    mutate(Term = row.names(.)) %>%
    select(Term, SE)
  
  nu <- mod.s$residual.df
  
  inner_join(E, SE) %>%
    mutate(L = Estimate +
             SE * qt(df = nu,
                     p = (1 - level) / 2),
           U = Estimate +
             SE * qt(df = nu,
                     p = 1 - (1 - level) / 2)) %>%
    return
  
}

gam.confint <- confint.paragam(gam.mod.log.2) %>% select(Term, Estimate, L, U)
```
```{r}

gam.confint.beds <- gam.confint %>% filter(grepl("beds", Term, fixed = T))
ggplot(gam.confint.beds, aes(x = Term, y = exp(Estimate), color = Term)) + geom_point(size = 3) + geom_errorbar(aes(ymin=exp(L), ymax=exp(U)), width=.3)
```

```{r}
gam.confint.baths <- gam.confint %>% filter(grepl("baths", Term, fixed = T))
ggplot(gam.confint.baths, aes(x = Term, y = exp(Estimate), color = Term)) + geom_point(size = 3) + geom_errorbar(aes(ymin=exp(L), ymax=exp(U)), width=.3)
```

