---
title: "Chicago Apartment Market EDA and LASSO"
output:
  pdf_document: default
  html_notebook: default
---

```{r include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```


```{r message=FALSE, error=FALSE, warning=FALSE}
set.seed(97) 
library(MASS)
library(ggplot2)
library(cluster)
library(factoextra)
library(data.table)
library(psych)
library(ggridges)
library(gridExtra)
library(GGally)
library(stringr)
library(glmnet)
library(caret)
library(doMC)
library(viridis)
library(gmodels)
registerDoMC(cores = 11) 
```

# Overview

The data is a set of apartment model information crawled from apartment.com on May 25th.
It contains about 17K apartment listings. Each entry is a specific type of apartment listed.
An overview of the variable is as follow:

* location informations:
    * address
    * state
    * zip
    * city
    * neighborhood
* room information:
    * beds
    * baths
    * sqft: the median sqft of the specific type of unit
    * rent: the median rent of the specific type of unit
* pet information:
    * pet.allowed: whether pets are allowed
    * pet.deposit
    * pet.fee
    * pet.rent
* parking information:
    * has.garage
    * garage.fee
    * has.lot
    * lot.fee
    * has.street
    * street.fee
    * has.convered
    * covered.fee
* counts of various types of schools listed on website, with variable *.School, and college.count
* counts of place of interests in the vicinity listed on the website
    * rec.num: number of parks or other recreational facility
    * transit.num: number of public transit stations
    * shopping.num: number of shopping centers
    * air.num: number of airports
    * rail.num: number of rail stations
    * base.num: number of military bases
* assessment of environment
    * transit.score: public transit score
    * sound.score
    * walk.score
    * bike.score
    * traffic.level
    * air.level
    * busi.level: the level of bussiness operations

The full data also has boolean variables indicating whether the given type of 
unit has a certain feature, i.e. microwave. It also has variables indicating the 
exact name of the school under the counts of the schools. However, for the initial 
analysis, they are not considered. The eventual goal is to be able to create a pricing 
model for the rent of generic apartment units based on the other information. Thus, 
it's a regression task with the goal of predicting the rent from the other variables.

# EDA and Preprocessing

The data is loaded from the csv file, and only the variables listed above are retained.
Since the main interest would be to predict the rent, any units without rent listed 
are discarded.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw <- read.csv("./compile.csv")
apartments_raw_small <- apartments_raw[, c(2:54)]
apartments_raw_small <- apartments_raw_small[!is.na(apartments_raw_small$rent),]
apartments_raw_small <- apartments_raw_small[,order(colnames(apartments_raw_small))]
```

The latitude and longitude information for each apartment is also retrieved, and 
added to the scraped data.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartment.geo <- read.csv("geo.csv")
apartment.geo$full_addr <- apartment.geo$address
apartment.geo$address <- str_split_fixed(apartment.geo$full_addr, ", ", 2)[, 1]
apartment.geo <- apartment.geo[, -4]
head(apartment.geo)
apartments_raw_small <- merge(apartments_raw_small, apartment.geo, by="address")
```

## Distribution of Rent

The initial distribution of the rent seems to contain a large amount of outliers. 
There seems to be a number of units with rents >= 10k dollars. Consequently, the 
plot was scaled so that the bulk of the apartments are squeezed at the bottom, while 
the outliers are highlighted on the top.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartments_raw_small, aes(y=rent)) + geom_boxplot(fill="slateblue", alpha=0.2)
```

With the IQR method, there are a total of 889 outliers in the dataset. It's a tiny 
amount compared to the whole dataset of around 17k apartments, but some of them may 
still be in the scope of interest.

```{r message=FALSE, error=FALSE, warning=FALSE}
out.rent <- boxplot.stats(apartments_raw_small$rent)$out
out.rent.ind <- which(apartments_raw_small$rent %in% c(out.rent))
length(out.rent)
```
The histogram of the outliers shows that the majority of outliers are under 10k in 
rents, and only a small percentage of the units are over 20k in rents.

```{r message=FALSE, error=FALSE, warning=FALSE}
histogram(out.rent)
```
A closer look at the the apartments with rent >= 20k shows that four out of five 
of them are from 368 Grand by Onni.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small[apartments_raw_small$rent >= 20000, 
                     c("name", "rent", "baths", "beds", "sqft")]
```

However, the median the of units at 369 Grand by Onni us only around 5k. Furthermore, 
the MAD is around 3k, which suggests that most of the units there are expensive, but not
to the point of the units shown above. A manual inspection of the website also shows that 
the units above 20k are some sort of special units in the complex. Since the purpose 
of the analysis is for "mass-produced" apartments for general residence, those 
special units are out of the scope of the analysis, so they can be discarded.

```{r message=FALSE, error=FALSE, warning=FALSE}
describe(apartments_raw_small[apartments_raw_small$name == "369 Grand by Onni", 
                              c("rent")])
```

In order to discard the special units from the complexes, the apartment units are compared 
with the rest of the units from the same apartment complex. Since the presence of thoseu
nits greatly affects the mean and standard deviation, the median and MAD 
are used to lessen the effect of the potential special units. Thus, for each 
apartmentunit, the following score is computed:

$$Score = |X - Median|/MAD$$

where X is the rent of the outlier unit. If the Score is greater than 3, then the unit 
is considered to be a special unit and discarded.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartment_comp_df <- apartments_raw_small[, c("address", "rent")]
out.stat.df <- as.data.frame(with(apartment_comp_df, tapply(rent, address, median)))
out.stat.df$mad <- with(apartment_comp_df, tapply(rent, address, mad))
colnames(out.stat.df) <- c("median", "mad")
out.stat.df$address <- rownames(out.stat.df)
apartment_comp_df <- merge(apartment_comp_df, out.stat.df, by="address")
apartment_comp_df$score <- (apartment_comp_df$rent - apartment_comp_df$median) / 
  apartment_comp_df$mad
apartment_comp_df[is.na(apartment_comp_df$score), "score"] <- 0
removal.score.ind <- abs(apartment_comp_df$score) >= 3
apartment_comp_df <- apartment_comp_df[!removal.score.ind, ]
```

After removing the special units, the rents of the remaining apartments are plotted. 
The procedure before removed some of outlier units, but there are still some hyper 
expensive units remaining. For most people, the units nearing or above 10k per month 
are definite out of reach. So, the remaining hyper expensive units are still out of 
the scope of the analysis. On the plot, it seems that the distribution discontinued 
itself at around \$7000 per month, so it was selected as the cutoff point for the 
outliers. Intuitively, it is also high enough to include the apartments that most people 
would be willing to afford.

```{r message=FALSE, error=FALSE, warning=FALSE}
bw_rent <- 2 * IQR(apartments_raw_small$rent) / length(apartments_raw_small$rent)^(1/3)
ggplot(apartment_comp_df, aes(x=rent)) + geom_histogram(bins=bw_rent, fill="#69b3a2", 
                                                        color="#e9ecef", alpha=0.9)
apartments_raw_small <- apartments_raw_small[!removal.score.ind,]
apartments_raw_small <- apartments_raw_small[apartments_raw_small$rent < 7000, ]
```

The rent is plotted again after some of the outliers are discarded per the cutoff. 
The distribution of the rent is skewed to the right, with the center around 2k per month. 
However, the distribution also seems to be multi-modal, with the shape of the histogram 
being far from smooth. Based on the skewness, a log transformation was applied, which 
made the plot more symmetrical, but the different peaks are preserved.

```{r message=FALSE, error=FALSE, warning=FALSE}
rent.plot <- ggplot(apartments_raw_small, aes(x=rent)) + 
  geom_histogram(bins=bw_rent, fill="#69b3a2", 
  color="#e9ecef", alpha=0.9)
rent.logplot <- ggplot(apartments_raw_small, aes(x=log(rent))) + 
  geom_histogram(bins=bw_rent, fill="#69b3a2", 
  color="#e9ecef", alpha=0.9)
grid.arrange(rent.plot, rent.logplot)
```

The statistics of the rent presents a similar picture. The mean of the data is at \$2275, 
but the median is at \$2095, which is lower than the mean. Removing the top and bottom 
10% of the data decreased the mean to 2150, which is still a little bit higher than 
the median. The standard deviation of 1054.35 is higher than the mean absolute difference 
of 957.76, probably due to influences from the tail of the data. Finally, the skew is 
positive at 1.2, which implies that the distribution is somewhat skewed to the right.

```{r message=FALSE, error=FALSE, warning=FALSE}
describe(apartments_raw_small[,c("rent")])
```

## Distribution of Sqft

The sqft is roughly symmetrically distributed, with the center around 800. However, 
there is a group of larger apartments at around 2500 sqft, and a few apartment at 10k sqft 
in the raw data.

```{r message=FALSE, error=FALSE, warning=FALSE}
bw_sqft <- 2 * IQR(apartments_raw_small$sqft, na.rm=TRUE) / 
  length(apartments_raw_small$sqft)^(1/3)
ggplot(apartments_raw_small, aes(x=sqft)) + geom_histogram(bins=bw_sqft, fill="#69b3a2", 
                                                           color="#e9ecef", alpha=0.9)
```

A closer inspection of the website revealed that it's very unlikely for the apartments 
with roughly 10k sqft listed to be actually that big, so the sqft is set to NaN. Furthermore, 
there is an apartment model with a data entry error, so it is also corrected.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small$sqft <- ifelse(apartments_raw_small$sqft == 9999, NaN, 
                                    apartments_raw_small$sqft)
apartments_raw_small[apartments_raw_small$address == "2834 W Warren Blvd", c("address", "sqft")]
apartments_raw_small["2471", "sqft"] <- 1710
```

The statistics of the sqfts show that there are apartments with 1 sqft listed. However, 
that is highly unlikely since they also have bathrooms and living room. Thus, 200 sqft (the 
size of a small college dorm room) was picked as the cutoff line, and the column was 
reset for all the units with <= 200 sqft areas.

```{r message=FALSE, error=FALSE, warning=FALSE}
describe(apartments_raw_small$sqft, fast = T)
apartments_raw_small$sqft <- ifelse(apartments_raw_small$sqft <= 200, NaN, apartments_raw_small$sqft)
```

The sqft became skewed after the potentially incorrect data is removed. A log transformation 
can be applied to make it symmetrical. However, it is multimodal with 2-4 potential 
peaks in the distribution.

```{r message=FALSE, error=FALSE, warning=FALSE}
bw_sqft <- 2 * IQR(apartments_raw_small$sqft, na.rm=TRUE) / 
  length(apartments_raw_small$sqft)^(1/3)
sqft.plot <- ggplot(apartments_raw_small, aes(x=sqft)) + 
  geom_histogram(bins=bw_sqft, fill="#69b3a2", 
  color="#e9ecef", alpha=0.9)
sqft.plog <- ggplot(apartments_raw_small, aes(x=log(sqft))) + 
  geom_histogram(bins=bw_sqft, fill="#69b3a2", 
  color="#e9ecef", alpha=0.9)
grid.arrange(sqft.plot, sqft.plog)
```

## Cleaning lot.fee

It turns out that there is one apartment unit with $10000 fee for the surface parking 
lot. It is clearly an error in the input, and the fee has been corrected to $100. 
After the correction, the distribution of fee looked much more reasonable, with most 
apartment charging nothing for parking.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small[apartments_raw_small$lot.fee >= 500, c("address", "lot.fee", "rent")]
apartments_raw_small["1970", "lot.fee"] <- 100
ggplot(apartments_raw_small, aes(x=lot.fee)) + geom_histogram(bins=30, fill="#69b3a2", 
                                                           color="#e9ecef", alpha=0.9)
```

## Assessment of street.fee

A frequency table of street.fee shows that essentially all of the apartments listed 
doesn't charge for parking on the street. There are only a handful of apartments that charges 
for street parking. Thus, the column doesn't add much to the data, so it is dropped.

```{r message=FALSE, error=FALSE, warning=FALSE}
table(apartments_raw_small$street.fee)
apartments_raw_small <- apartments_raw_small[, -which(names(apartments_raw_small) 
                                                      %in% c("street.fee"))]
```

## Distribution of Environment Scores

The following histograms plot the rating of the environment listed on the website. 
A good portion of the apartments have perfect public transit score, while the rest follow 
a normal-ish distribution centered at 75. Most of the apartments has decent walking 
score, but the distribution is skewed to the left. The sound.score has separated bars 
in comparison to the other scores. It may be related to the way that the score is 
calculated or defined. However, it also suggests that apartments in Chicago have more 
distinct soundscapes. Finally, roughly 750 apartments had perfect bike scores, and the 
rest are distributed with a skew to the left. There are also a few score range with 
high amount of apartments as compared to the other ranges.

```{r message=FALSE, error=FALSE, warning=FALSE}
transit.plot <- ggplot(apartments_raw_small, aes(x=transit.score)) + 
  geom_histogram(bins=50, fill="#69b3a2", color="#e9ecef", alpha=0.9)
walk.plot <- ggplot(apartments_raw_small, aes(x=walk.score)) + 
  geom_histogram(bins=50, fill="#69b3a2", color="#e9ecef", alpha=0.9)
sound.plot <- ggplot(apartments_raw_small, aes(x=sound.score)) + 
  geom_histogram(bins=50, fill="#69b3a2", color="#e9ecef", alpha=0.9)
bike.plot <- ggplot(apartments_raw_small, aes(x=bike.score)) + 
  geom_histogram(bins=50, fill="#69b3a2", color="#e9ecef", alpha=0.9)
grid.arrange(transit.plot, walk.plot, sound.plot, bike.plot)
```

## Missing values

There are 2921 apartments with missing sqft. It does consitute a significant portion 
of the apartment data. Thus, it would be a worthwhile effort to try to fill in the 
missing values. However, there are a small amount of apartments with missing environment 
scores. They are minor compared to the total of 17k apartments. Furthermore, the missing 
values indicate an error on the webpage, since the score should be provided to all 
the apartments automatically. Thus, those apartments are dropped.

```{r message=FALSE, error=FALSE, warning=FALSE}
nrow(apartments_raw_small[is.na(apartments_raw_small$sqft),])
nrow(apartments_raw_small[is.na(apartments_raw_small$walk.score),])
nrow(apartments_raw_small[is.na(apartments_raw_small$bike.score),])
nrow(apartments_raw_small[is.na(apartments_raw_small$transit.score),])
nrow(apartments_raw_small[is.na(apartments_raw_small$sound.score),])
apartments_raw_small <- apartments_raw_small[!is.na(apartments_raw_small$sound.score),]
apartments_raw_small <- apartments_raw_small[!is.na(apartments_raw_small$transit.score),]
apartments_raw_small <- apartments_raw_small[!is.na(apartments_raw_small$bike.score),]
apartments_raw_small <- apartments_raw_small[!is.na(apartments_raw_small$walk.score),]
```

## Retyping the variables

Some of the potential categorical variables are converted to characters temporarily 
to have more flexibility. The missing values in pet.allowed are renamed to "unknown."
Finally, the logical variables are typed properly as logical binary variables.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small$zip = as.factor(apartments_raw_small$zip)
apartments_raw_small$neighborhood = as.character(apartments_raw_small$neighborhood)
apartments_raw_small$beds = as.character(apartments_raw_small$beds)
apartments_raw_small$baths = as.character(apartments_raw_small$baths)

apartments_raw_small$pet.allowed <- as.character(apartments_raw_small$pet.allowed)
apartments_raw_small[apartments_raw_small$pet.allowed == "", c("pet.allowed")] <- "unknown"
apartments_raw_small$pet.allowed = as.factor(apartments_raw_small$pet.allowed)

apartments_raw_small$air.level = as.character(apartments_raw_small$air.level)
apartments_raw_small$traffic.level = as.character(apartments_raw_small$traffic.level)
apartments_raw_small$busi.level = as.character(apartments_raw_small$busi.level)
apartments_raw_small$has.covered = as.logical(apartments_raw_small$has.covered)
apartments_raw_small$has.lot = as.logical(apartments_raw_small$has.lot)
apartments_raw_small$has.garage = as.logical(apartments_raw_small$has.garage)
apartments_raw_small$has.street = as.logical(apartments_raw_small$has.street)

apartments_raw_small$has.parking <- apartments_raw_small$has.covered |
                                    apartments_raw_small$has.garage |
                                    apartments_raw_small$has.lot |
                                    apartments_raw_small$has.street
```

## Beds and Baths plot

The proportions of the number of bedrooms and bathrooms for the apartments are 
plotted below. Most of the apartments are either studio or has less than 4 bedrooms. 
The proportion of studio apartments are similar to the proportion of 3 bedroom apartments.
Furthermore, the proportion of 1 and 2 bedroom apartments are similar.

In terms of bathrooms, almost 75% of the apartments only have 1 bathroom. The rest of 
the apartments essentially have 2 bathrooms. Not much apartments in Chicago has half-bathrooms, 
but the most common arrangement of half-bathrooms seems to be 1 full bath + 1 half bath.

```{r message=FALSE, error=FALSE, warning=FALSE}
plot_as_percentage <- function(df, col, varname="", title="") {
  freq_df <- data.frame(table(df[, c(col)]))
  freq_df$Freq <- freq_df$Freq / sum(freq_df$Freq)
  colnames(freq_df) <- c(col, "Freq")
  if(varname == "") {
    varname <- col
  }
  df_plot <- ggplot(freq_df, aes(x="", y=Freq)) + aes_string(fill=col) +
    geom_bar(stat="identity", width=1, color="white") +
    coord_polar("y", start=0) + labs(fill = varname)
  if(title != "") {
    df_plot <- df_plot + ggtitle(title)
  }
  return(df_plot)
}

bed_plot <- plot_as_percentage(apartments_raw_small, "beds")
baths_plot <- plot_as_percentage(apartments_raw_small, "baths")

grid.arrange(bed_plot, baths_plot, ncol=2)
```

The frequency table of the baths and beds are given below. Since the purpose is to 
build a pricing model for the common apartments, the apartments with more than 4 
bedrooms can be discarded. Intuitively, those are not the kind of apartments that would 
be on the radar of most families/individuals. The small percentage of apartments in the 
market with more than 4 bedroom also suggests that they are fairly exotic. Furthermore, 
there are only 2 apartments with only a half bath. It is also not under consideration for 
most people since they won't have a shower or bath. Thus, they can be discarded as well. 
Additionally, a close inspection of the apartments with 9 bathroom suggested that the bathroom 
count does not match with the bedroom or sqft, so those are likely to contain data 
entry error, so they are discarded as well. Finally, there are only 2 apartments with 
4.5 bathrooms, so they are too small to be a category on their own. Thus, they can be 
merged with the apartments with 4 bathrooms.

```{r message=FALSE, error=FALSE, warning=FALSE}
CrossTable(apartments_raw_small$beds)
CrossTable(apartments_raw_small$baths)

apartments_raw_small <- apartments_raw_small[apartments_raw_small$baths < 9, ]
apartments_raw_small <- apartments_raw_small[apartments_raw_small$baths > 0.5, ]
apartments_raw_small <- apartments_raw_small[apartments_raw_small$beds <= 4, ]
apartments_raw_small[apartments_raw_small$baths == 4.5, ]$baths <- 4
```

The updated frequencies are tabulated below. Interestingly, there are a few case 
where the number of bathrooms are greater than the number of bedrooms. For example, 
there are 4 studio apartments with 2 bathrooms. Thus, it prompts a closer look 
to determine whether the entries are correct.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small$beds <- as.numeric(apartments_raw_small$beds)
apartments_raw_small$baths <- as.numeric(apartments_raw_small$baths)

baths <- apartments_raw_small$baths
beds <- apartments_raw_small$beds
CrossTable(beds, baths, prop.chisq=F)
```

### Inspecting Studio apartments

The mirrored plot of the apartments with expected number of 
bathrooms vs unexpected is shown below. The expected group is centered at around 
500 sqft area with a few apartments in the >=750 sqft range. For the unexpected group, 
there are a few apartments in the 500 sqft range, and a few apartments that are clearly 
larger than most.

```{r message=FALSE, error=FALSE, warning=FALSE}
studio <- apartments_raw_small[beds == 0, ]
studio$expected <- T
studio[studio$baths >= 1.5, "expected"] <- F
ggplot(studio, aes(x=sqft, fill=expected, group=expected)) + 
  geom_histogram(data=studio[studio$expected, ], aes(y=..density..)) +
  geom_histogram(data=studio[!studio$expected, ], aes(y=-..density..))
```

A look at the smaller unexpected apartments shows that all except for 8701 definitely 
only has 1 bathroom. A look at the picture of 8701 shows that it only has 1 baths. Thus, 
the bathrooms are corrected to 1.

```{r message=FALSE, error=FALSE, warning=FALSE}
studio.unexpected <- studio[!studio$expected, ]
studio.unexpected[studio.unexpected$sqft <= 800, c("address", "rent", "sqft", "baths")]
row.update <- rownames(studio.unexpected[studio.unexpected$sqft <= 800,])
apartments_raw_small[which(rownames(apartments_raw_small) %in% row.update), "baths"] <- 1
```

### Inspecting 1 bedroom apartments

In the 1 bedroom case, the unexpected units are clearly shifted to the left from 
the expected unit, and both had similar shape. In either case, there are a few 
units that are notably bigger than the rest.

```{r message=FALSE, error=FALSE, warning=FALSE}
one_bed <- apartments_raw_small[apartments_raw_small$beds == 1, ]
one_bed$expected <- T
one_bed[one_bed$baths >= 1.5, "expected"] <- F
ggplot(one_bed, aes(x=sqft, fill=expected, group=expected)) + 
  geom_histogram(data=one_bed[one_bed$expected, ], aes(y=..density..), bins=40) +
  geom_histogram(data=one_bed[!one_bed$expected, ], aes(y=-..density..), bins=40)
```

It is calculated that the mean of the expected unit is centered at 728.67 sqft while 
the unexpected unit is centered at 987.62. The expected units have a standard deviation 
of 162.33 while the unexpected ones have a higher standard deviation of 239.11.

```{r message=FALSE, error=FALSE, warning=FALSE}
describeBy(sqft~expected, data=one_bed, fast=T)
```

A look at the unexpected units with sqft below the mean of the expected units shows 
a few candidates for correction. The floor plan was looked up, and the bathroom number 
of 13486 and 13499 is corrected to 1.

```{r message=FALSE, error=FALSE, warning=FALSE}
one_bed.unexpected <- one_bed[!one_bed$expected & !is.na(one_bed$sqft), ]
one_bed.unexpected[one_bed.unexpected$sqft <= 750, c("name", "rent", "sqft", "baths")]
apartments_raw_small[c("13486", "13499"), "baths"] <- 1
```

Additionally, the notably large units are selected below as well. After a few search, 
it turned out that 15693 is a room in the whole building, but the sqft of the entire 
building is listed on the website. Thus, the sqft is reset to NaN.

```{r message=FALSE, error=FALSE, warning=FALSE}
one_bed[!is.na(one_bed$sqft) & one_bed$sqft >= 2000,  c("name", "rent", "sqft", "baths")]
apartments_raw_small[which(rownames(apartments_raw_small) 
                     %in% c("15693")), "sqft"] <- NaN
```

### Inspecting 2 bedroom apartments

The 2 bedroom apartments also displayed a shift between the expected and unexpected units. 
The center of the expected units sits at around 1050 sqft, while the center of the unexpected 
units sit at around 1500 sqft. There is a group of unexpected units with sqft at the 
center of the expected units. Furthermore, there's also 2 clusters of unexpected units 
that's clearly larger than the rest.

```{r message=FALSE, error=FALSE, warning=FALSE}
two_bed <- apartments_raw_small[apartments_raw_small$beds == 2, ]
two_bed$expected <- T
two_bed[two_bed$baths >= 2.5, ]$expected <- F
ggplot(two_bed, aes(x=sqft, fill=expected, group=expected)) + 
  geom_histogram(data=two_bed[two_bed$expected, ], aes(y=..density..), bins=40) +
  geom_histogram(data=two_bed[!two_bed$expected, ], aes(y=-..density..), bins=40)
```

An inspection of the floor plan online revealed that the smaller units with 2.5 baths 
actually do have 2.5 baths, so no correction is needed.

```{r message=FALSE, error=FALSE, warning=FALSE}
two_bed.unexpected <- two_bed[!two_bed$expected & !is.na(two_bed$sqft), ]
two_bed.unexpected[two_bed.unexpected$sqft <= 1100, c("name", "rent", "sqft", "baths")]
```

For the larger units, a search revealed that 15845, 15851, and 1090 are the special 
units offered in the apartments. They are not the usual units that a renter would 
most likely rent in the building. Thus, they are discarded.

```{r message=FALSE, error=FALSE, warning=FALSE}
two_bed[!is.na(two_bed$sqft) & two_bed$sqft >= 2600, 
        c("name", "rent", "sqft", "baths")]
apartments_raw_small <- apartments_raw_small[-which(rownames(apartments_raw_small) 
                                             %in% c("15845", "15851", "1090")), ]
```


### Inspecting 3 bedroom apartment

For the three bedroom case, as suggested by the frequency table, there's only a 
handful of unexpected units. Hence, they formed a few cluster vs the expected units 
which formed an almost symmetric distribution. There seems to be 1 cluster of unexpected 
units around 1500 sqft, which seems to be the center of the expected units. The other 
unexpected units are clearly larger than most of the expected units. However, there's 
1 cluster of expected units that's larger than the rest.

```{r message=FALSE, error=FALSE, warning=FALSE}
three_bed <- apartments_raw_small[apartments_raw_small$beds == 3, ]
three_bed$expected <- T
three_bed[three_bed$baths >= 3.5, "expected"] <- F
ggplot(three_bed, aes(x=sqft, fill=expected, group=expected)) + 
  geom_histogram(data=three_bed[three_bed$expected, ], aes(y=..density..), bins=40) +
  geom_histogram(data=three_bed[!three_bed$expected, ], aes(y=-..density..), bins=40)
```

A search of the floor plan revealed that the small unexpected unit does indeed has 3.5 
bathrooms, so no correction is needed.

```{r message=FALSE, error=FALSE, warning=FALSE}
three_bed.unexpected <- three_bed[!three_bed$expected & !is.na(three_bed$sqft), ]
three_bed.unexpected[three_bed.unexpected$sqft <= 1600, 
                     c("name", "rent", "sqft", "baths")]
```

A search revealed that the sqft for 7846 is actually the total sqft of the building. 
Since no other information was able to be founded regarding the specific room rented, 
the sqft is reset back to NaN.

```{r message=FALSE, error=FALSE, warning=FALSE}
three_bed[!is.na(three_bed$sqft) & three_bed$sqft > 3000, 
          c("name", "rent", "sqft", "baths")]
apartments_raw_small[which(rownames(apartments_raw_small) 
                     %in% c("7846")), "sqft"] <- NaN
```

### Inspecting 4 bed apartments

As suggested by the frequency table, there are no apartments with >=4.5 bathrooms, 
so all of the units are expected here. There are only a handful of units in the 4 bed 
range compared to the rest, so the histogram is less smooth comparatively. Furthermore, 
there did not seem to be any significant outliers as far as sqft is concerned. The center 
for 4 bedroom units seems to be around 2000 sqft. There is a small 4 bedroom apartment isolated 
from the rest, and a cluster of larger sized apartments at around 3600 sqft.

```{r message=FALSE, error=FALSE, warning=FALSE}
four_bed <- apartments_raw_small[apartments_raw_small$beds == 4, ]
ggplot(four_bed, aes(x=sqft)) + 
  geom_histogram(aes(y=..density..), bins=30, fill="#69b3a2", color="#e9ecef", alpha=0.9)
```

A search of the small apartment revealed that it's a small building with 4 bedroom, 
so no correction is required.

```{r message=FALSE, error=FALSE, warning=FALSE}
four_bed[!is.na(four_bed$sqft) & four_bed$sqft <= 800, 
         c("name", "rent", "sqft", "baths")]
```

### Categorical Beds & Baths

A categorical version of the beds and baths variables is created for regression later. 
The finalized baths/beds are also plotted below.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small$bed_count <- as.character(apartments_raw_small$beds)
apartments_raw_small[apartments_raw_small$beds == 0, c("bed_count")] <- "studio"
apartments_raw_small$bed_count <- as.factor(apartments_raw_small$bed_count)
apartments_raw_small$bath_count <- as.factor(apartments_raw_small$baths)

bed.bath.freq <- data.frame(table(apartments_raw_small$bed_count, 
                                  apartments_raw_small$bath_count))
colnames(bed.bath.freq) <- c("Beds", "Baths", "Freq")
ggplot(bed.bath.freq, aes(fill=Baths, y=Freq, x=Beds)) + 
    geom_bar(position="stack", stat="identity")
```


## Various categorical variables

### Pet Policy

The proportions of apartments by pet policy is plotted below. Almost 70% of the 
apartments allow pets, while approx 15% did not post a pet policy, or indicated that 
the pet policy is negotiable.

```{r message=FALSE, error=FALSE, warning=FALSE}
plot_as_percentage(apartments_raw_small, "pet.allowed")
```

### Parking

The proportion of apartments by parking is plotted. Almost 70% of the apartments 
has parking. 

```{r message=FALSE, error=FALSE, warning=FALSE}
plot_as_percentage(apartments_raw_small, "has.parking")
```

The apartments can also be broken down by specific parking type. Of the apartments 
with parking, approx 50% has lot or garage. About 25% of the apartments has a 
street parking arrangement. Finally, the least popular option is the covered parking lot.

```{r message=FALSE, error=FALSE, warning=FALSE}
lot_plot <- plot_as_percentage(apartments_raw_small[apartments_raw_small$has.parking, ], 
                               "has.lot")
garage_plot <- plot_as_percentage(apartments_raw_small[apartments_raw_small$has.parking, ], 
                                  "has.garage")
covered_plot <- plot_as_percentage(apartments_raw_small[apartments_raw_small$has.parking, ], 
                                   "has.covered")
street_plot <-plot_as_percentage(apartments_raw_small[apartments_raw_small$has.parking, ], 
                                 "has.street")

grid.arrange(lot_plot, garage_plot, covered_plot, street_plot)
```

### Schools

#### Elementary Schools

Most of the apartments doesn't have any sort of public or private schools listed 
on the website. If an apartment has a listed public school, then it's almost certainly 
just 1 school. The same can be said for the private school version. Thus, 2 categorical 
variables are created to simply indicate whether an apartment has an elementary school 
nearby.

```{r message=FALSE, error=FALSE, warning=FALSE}
pub.elementary.plot <- plot_as_percentage(apartments_raw_small, 
                                          "Public.Elementary.School",
                                          "Count", "Public Elementary School")
priv.elementary.plot <- plot_as_percentage(apartments_raw_small, 
                                           "Private.Elementary.School",
                                           "Count", "Private Elementary School")
grid.arrange(pub.elementary.plot, priv.elementary.plot, ncol=2)
apartments_raw_small$has.pub.elementary <- 
  apartments_raw_small$Public.Elementary.School >= 1
apartments_raw_small$has.priv.elementary <- 
  apartments_raw_small$Private.Elementary.School >= 1
```

#### Middle School

Almost no apartments have a private middle school listed as nearby. But, a small 
percentage has 1 or 2 public middle school. Then, by similar reasoning, 1 categorical 
variable is created to indicate whether an apartment has a public middle school nearby.

```{r message=FALSE, error=FALSE, warning=FALSE}
pub.mid.plot <- plot_as_percentage(apartments_raw_small, "Public.Middle.School",
                                   "Count", "Public Middle School")
priv.mid.plot <- plot_as_percentage(apartments_raw_small, "Private.Middle.School",
                                    "Count", "Private Middle School")
grid.arrange(pub.mid.plot, priv.mid.plot, ncol=2)
apartments_raw_small$has.pub.mid <- apartments_raw_small$Public.Middle.School >= 1
```
#### High School

As expected, the charter high school is not very common among the apartments, but some 
do have a charter high school nearby. The private high school is more popular, but only 
25% of the units has a private high school nearby. The public high school present a more 
diverse picture. More than half of the apartments has a public high school in proximity. 
Of the apartments that have a public high school nearby, 2 high school is the most common 
arrangement. Thus, 2 indicate variables are created for the proximity of charter/private 
high school. One categorical variable is created for the number of public high school. 
Since there are only a few apartments with more than 3 public high school nearby, 
all the apartments with more than 3 public high schools are grouped together.

```{r message=FALSE, error=FALSE, warning=FALSE}
cha.hi.plot <- plot_as_percentage(apartments_raw_small, "Charter.High.School",
                                  "Count", "Charter High School")
pub.hi.plot <- plot_as_percentage(apartments_raw_small, "Public.High.School",
                                  "Count", "Public High School")
priv.hi.plot <- plot_as_percentage(apartments_raw_small, "Private.High.School",
                                   "Count", "Private High School")
grid.arrange(cha.hi.plot, pub.hi.plot, priv.hi.plot, ncol=2)

apartments_raw_small$has.cha.high <- apartments_raw_small$Charter.High.School >= 1
apartments_raw_small$has.priv.high <- apartments_raw_small$Private.High.School >= 1
apartments_raw_small$count.pub.high <- as.character(apartments_raw_small$Public.High.School)
apartments_raw_small[apartments_raw_small$Public.High.School > 3, 
                     c("count.pub.high")] <- "4_or_more"
apartments_raw_small$count.pub.high <- as.factor(apartments_raw_small$count.pub.high)
```

#### Elementary/Middle School

It appears that the lack of elementary school earlier corresponds to the prevalence 
of combined elementary/middle school. More than half of the apartments has at least 
1 public elementary/middle school nearby. Of the ones with schools, the most common 
arrangements are 1 or 2 combined elementary/middle school.

```{r message=FALSE, error=FALSE, warning=FALSE}
plot_as_percentage(apartments_raw_small, 
                   "Public.Elementary.Middle.School",
                   "Count", "Public Elementary/Middle School")
```

The private elementary/middle school presents a similar image. Slightly less than 
half of the apartments has a combined private elementary/middle school. But, unlike 
the public school situation, most of the apartments with a private school only has 
1 private school nearby. However, unlike the public/private school situation, 
there are virtually no charter elementary/middle school that's near any apartments.

```{r message=FALSE, error=FALSE, warning=FALSE}
cha.el.mi.plot <- plot_as_percentage(apartments_raw_small, 
                                     "Charter.Elementary.Middle.School",
                                     "Count", "Charter Elementary/Middle School")
priv.el.mi.plot <- plot_as_percentage(apartments_raw_small, 
                                      "Private.Elementary.Middle.School",
                                      "Count", "Private Elementary/Middle School")
grid.arrange(cha.el.mi.plot, priv.el.mi.plot, ncol=2)
```

Categorical variables for public and private elementary/middle schools are created. 
The categories with less than 10 data points are compacted together.

```{r message=FALSE, error=FALSE, warning=FALSE}
table(apartments_raw_small$Public.Elementary.Middle.School)
table(apartments_raw_small$Private.Elementary.Middle.School)

apartments_raw_small$pub.elt.mid <- 
  as.character(apartments_raw_small$Public.Elementary.Middle.School)
apartments_raw_small[apartments_raw_small$Public.Elementary.Middle.School >=6, 
                     c("pub.elt.mid")] <- "6_or_more"
apartments_raw_small$pub.elt.mid <- as.factor(apartments_raw_small$pub.elt.mid)
apartments_raw_small$priv.elt.mid <- 
  as.character(apartments_raw_small$Private.Elementary.Middle.School)
apartments_raw_small[apartments_raw_small$Private.Elementary.Middle.School >=3, 
                     c("priv.elt.mid")] <- "3_or_more"
apartments_raw_small$priv.elt.mid <- as.factor(apartments_raw_small$priv.elt.mid)
```

#### Middle/High School

Compared to the prevalence of combined elementary/middle school, the combined 
middle/high schools are not as popular. Most of the apartments have no combined 
middle/high school nearby. Of the ones with a school of this kind, the most common 
type is the public middle/high school.

```{r message=FALSE, error=FALSE, warning=FALSE}
cha.mi.hi.plot <- plot_as_percentage(apartments_raw_small, 
                                     "Charter.Middle.High.School",
                                     "Count", "Charter Middle/High School")
pub.mi.hi.plot <- plot_as_percentage(apartments_raw_small, "Public.Middle.High.School",
                                     "Count", "Public Middle/High School")
priv.mi.hi.plot <- plot_as_percentage(apartments_raw_small, 
                                      "Private.Middle.High.School",
                                      "Count", "Private Middle/High School")
grid.arrange(cha.mi.hi.plot, pub.mi.hi.plot, priv.mi.hi.plot, ncol=2)
```

Although rare, there are still a considerable amount of units with a combined 
middle/high school, so indicator variables are created for those school types.

```{r message=FALSE, error=FALSE, warning=FALSE}
table(apartments_raw_small$Charter.Middle.High.School)
table(apartments_raw_small$Private.Middle.High.School)
apartments_raw_small$has.cha.mid.high <- 
  apartments_raw_small$Charter.Middle.High.School >= 1
apartments_raw_small$has.priv.mid.high <- 
  apartments_raw_small$Private.Middle.High.School >= 1
apartments_raw_small$has.pub.mid.high <- 
  apartments_raw_small$Public.Middle.High.School >= 1
```

### Misc. Combined School

Interestingly, there are some apartments with private combined elementary/high schools.
There are also some apartments with charter or public combined elementary/middle/high schools.
Of those school types, the private all-3-combined option seems to be the most popular. On 
the other hand, there are virtually no public all-3-combined schools.

```{r message=FALSE, error=FALSE, warning=FALSE}
priv.el.hi.plot <- plot_as_percentage(apartments_raw_small, 
                                      "Private.Elementary.High.School",
                                      "Count", "Private Elementary/High School")
ch.el.mi.hi.plot <- plot_as_percentage(apartments_raw_small, 
                                       "Charter.Elementary.Middle.High.School",
                                       "Count", "Charter Elementary/Middle/High")
pub.el.mi.hi.plot <- plot_as_percentage(apartments_raw_small, 
                                        "Public.Elementary.Middle.High.School",
                                        "Count", "Public Elementary/Middle/High")
priv.el.mi.hi.plot <- plot_as_percentage(apartments_raw_small, 
                                         "Private.Elementary.Middle.High.School",
                                         "Count", "Private Elementary/Middle/High")
grid.arrange(priv.el.hi.plot, ch.el.mi.hi.plot, pub.el.mi.hi.plot, priv.el.mi.hi.plot)
```

A categorical variable is created for the all 4 types above with the exception for 
the public combined version, since the public combined schools are so rare. The category 
is also compacted if there are only a few data points.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small$priv.el.hi <- 
  as.factor(apartments_raw_small$Private.Elementary.High.School)
apartments_raw_small$cha.elt.mid.hi <- 
  apartments_raw_small$Charter.Elementary.Middle.High.School >= 1
apartments_raw_small$priv.elt.mid.hi <- 
  as.character(apartments_raw_small$Private.Elementary.Middle.High.School)
apartments_raw_small[apartments_raw_small$Private.Elementary.Middle.High.School >= 2,
                     c("priv.elt.mid.hi")] <- "2_or_more"
apartments_raw_small$priv.elt.mid.hi <- 
  as.factor(apartments_raw_small$priv.elt.mid.hi)
```

#### Colleges

Virtually all of the apartments have a college nearby listed on the website, so 
it's not very useful.

```{r message=FALSE, error=FALSE, warning=FALSE}
plot_as_percentage(apartments_raw_small, 
                   "college.count",
                   "Count", "Colleges")
```

#### Clean up

Since an appropriate categorical version of the variables are created, the original 
variables can be discarded.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small <- apartments_raw_small[, -which(names(apartments_raw_small) 
  %in% c("Private.Elementary.High.School", "Charter.Elementary.Middle.High.School",
  "Public.Elementary.Middle.High.School", "Private.Elementary.Middle.High.School",
  "Charter.Middle.High.School", "Public.Middle.High.School",
  "Private.Middle.High.School", "Charter.Elementary.Middle.School",
  "Public.Elementary.Middle.School", "Private.Elementary.Middle.School",
  "Charter.High.School", "Public.High.School", "Private.High.School",
  "Public.Middle.School", "Private.Middle.School",
  "Public.Elementary.School", "Private.Elementary.School"))]
apartments_raw_small <- apartments_raw_small[, -which(names(apartments_raw_small) 
                        %in% c("college.count"))]
```

### Activity levels

The activity levels for the apartments are plotted below. Almost all of the apartments 
feel no interruptions from some airports nearby. Almost 60% of the apartments 
experience active traffic in the surrounding. Essentially all of the apartments have 
active or busy bussiness activities in the area.

```{r message=FALSE, error=FALSE, warning=FALSE}
air_level_plot <- plot_as_percentage(apartments_raw_small, "air.level")
traffic_level_plot <- plot_as_percentage(apartments_raw_small, "traffic.level")
busi_level_plot <- plot_as_percentage(apartments_raw_small, "busi.level")
grid.arrange(air_level_plot, traffic_level_plot, busi_level_plot, ncol=2)
```

All of the activity levels have some data points, so they are simply turned into 
categorical variables.

```{r message=FALSE, error=FALSE, warning=FALSE}
table(apartments_raw_small$traffic.level)
table(apartments_raw_small$busi.level)
table(apartments_raw_small$air.level)

apartments_raw_small$air.level <- as.factor(apartments_raw_small$air.level)
apartments_raw_small$traffic.level <- as.factor(apartments_raw_small$traffic.level)
apartments_raw_small$busi.level <- as.factor(apartments_raw_small$busi.level)
```

### Points of Interest

Almost 90% of the apartments has a shopping center nearby. Of the ones with shopping 
center, the most common number of shopping center is 3, while 2 and 1 are evenly split. 
Military bases are listed almost universally on the website for the apartments. Similarly, 
almost all of the apartments has 5 recreational centers listed.

```{r message=FALSE, error=FALSE, warning=FALSE}
shopping.num.plot <- plot_as_percentage(apartments_raw_small, "shopping.num")
rec.num.plot <- plot_as_percentage(apartments_raw_small, "rec.num")
base.num.plot <- plot_as_percentage(apartments_raw_small, "base.num")
grid.arrange(shopping.num.plot, rec.num.plot, base.num.plot, ncol=2)
```

Virtually all of the apartments have the same number of rail station, airports, 
or transit station listed on the webpage, so the variables here are not very useful.

```{r message=FALSE, error=FALSE, warning=FALSE}
rail.num.plot <- plot_as_percentage(apartments_raw_small, "rail.num")
air.num.plot <- plot_as_percentage(apartments_raw_small, "air.num")
transit.num.plot <- plot_as_percentage(apartments_raw_small, "transit.num")
grid.arrange(rail.num.plot, air.num.plot, transit.num.plot, ncol=2)
```

In the end, the variables without much data points in the 0 category are dropped, 
while the military base is turned into categorical variable. The shoping center variable 
is retained as before.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small <- apartments_raw_small[, -which(names(apartments_raw_small) 
                        %in% c("transit.num", "air.num", "rail.num", "rec.num"))]
apartments_raw_small$base.num <- apartments_raw_small$base.num != 0
apartments_raw_small$base.num <- as.factor(apartments_raw_small$base.num)
```


### Relation between the number of shopping center and business level

Interestingly, the business levels are pretty evenly split between the different 
levels of shopping centers. Thus, the criteria for business level may not be 
very related to the shopping centers.

```{r message=FALSE, error=FALSE, warning=FALSE}
shop.busi.freq <- data.frame(table(apartments_raw_small$shopping.num, 
                                   apartments_raw_small$busi.level))
colnames(shop.busi.freq) <- c("Shopping", "Busy", "Freq")
ggplot(shop.busi.freq, aes(fill=Busy, y=Freq, x=Shopping)) + 
    geom_bar(position="stack", stat="identity")
```

However, a chi-squared test reveals that the two variables are not independent. Thus, 
there may be some influence from the number of business centers nearby to the assessment 
of the business level provided by the website.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartment_busi_test <- apartments_raw_small[apartments_raw_small$busi.level != "-", ]
apartment_busi_test$busi.level <- as.character(apartment_busi_test$busi.level)
chisq.test(table(apartment_busi_test$shopping.num, 
                 apartment_busi_test$busi.level))
```

## Predictors

### Sqft vs. Beds/Baths

The log(baths + 1) and beds are plotted against log(sqft), since the sqft transformation 
evens out the distribution of sqft more to reduce influential points. In both cases, 
there is a general positive correlation between the log(sqft) and the variable. 
In the beds case, a linear function was able to approximate the trend decently. 
The regression line passed through all the boxes, and was near the center of the distribution. 
Additionally, the distribution of log(sqft) for each bedroom count seemed to be mostly 
symmetrical, which suggests that it may potentially meet the assumptions for gaussian 
noise.

For the baths case, the upward trend continued until the units with 4 bathrooms.
Furthermore, the distribution of log(sqft) is clearly less linear, with the line failing 
to meet the center of the distribution.

```{r message=FALSE, error=FALSE, warning=FALSE}
coefs.sqft.beds <- coef(lm(log(sqft) ~ beds, data = apartments_raw_small))
coefs.sqft.baths <- coef(lm(log(sqft) ~ log(baths + 1), data = apartments_raw_small))
bed.sqft.box <- ggplot(apartments_raw_small, aes(x=beds, y = log(sqft))) +
  geom_boxplot(aes(group=beds)) + 
  geom_abline(intercept = coefs.sqft.beds[1], slope = coefs.sqft.beds[2],
              color="red", alpha=0.5)
bath.sqft.box <- ggplot(apartments_raw_small, 
                        aes(x=log(baths + 1), group=log(baths + 1), y = log(sqft))) +
                        geom_boxplot() +
                        geom_abline(intercept = coefs.sqft.baths[1], 
                                    slope = coefs.sqft.baths[2],
                                    color="red", alpha=0.5)
grid.arrange(bed.sqft.box, bath.sqft.box, ncol=2)
```

### Rents vs. Beds/Baths

For log(rents), both beds and log(baths + 1) showed strong positive correlation. 
Similar to the sqft case, applying a log transformation to rents evens out the distribution, 
while the transformation stretches the baths number so that a line can fit better. 
However, in this case, the studio rents are skewed somewhat to the right. Thus, 
a regular linear regression line passes above the median of the studio distribution. 
In other cases, it was near the median of the rent distribution by bedrooms. 

For the bathrooms, the linear pattern fitted well until 2.5 baths. Additionally, 
the distribution of rents for 4 baths is extremely skewed to the right, with 50% of the 
data concentrated at the lower end of the distribution. Thus, the linear function 
significantly over-estimated the rent.

```{r message=FALSE, error=FALSE, warning=FALSE}
coefs.rent.beds <- coef(lm(log(rent) ~ beds, data = apartments_raw_small))
coefs.rent.baths <- coef(lm(log(rent) ~ log(baths + 1), data = apartments_raw_small))

bed.rent.plt <- ggplot(apartments_raw_small, 
                       aes(group=beds, x=beds, y = log(rent))) +
  geom_boxplot() +
  geom_abline(intercept = coefs.rent.beds[1], slope = coefs.rent.beds[2],
              color="red", alpha=0.5)
bath.rent.plt <- ggplot(apartments_raw_small, 
                        aes(group=log(baths + 1), x=log(baths + 1), y = log(rent))) +
  geom_boxplot() +
  geom_abline(intercept = coefs.rent.baths[1], slope = coefs.rent.baths[2],
              color="red", alpha=0.5)
grid.arrange(bed.rent.plt, bath.rent.plt, ncol=2)
```

### Beds/Baths interactions

In the ridgeline plots for log(sqft) vs beds and baths, the linear pattern between 
beds and log(sqft) persisted. For each bedroom count, the log(sqft) distribution shifted 
forward with the increase in bathroom until 4 bedroom apartments. The amount shifted 
was different between the bedroom counts. Thus, it suggests that an interaction term 
would be needed to take into account of the difference in the shift between bedroom 
count.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartments_raw_small, aes(x = log(sqft), y = bed_count, fill = bath_count)) +
  geom_density_ridges_gradient()
```

The situation seems to be more chaotic for rent. The distribution of log(rent) for 
each bathroom and bedroom seemed to be multi-modal and non-symmetric. However, 
the positive trend between bedroom count and log(rent) still persist. Furthermore, 
the distribution of log(rent) shifted forward with the bathroom count until apartments 
with 4 bedrooms. Similar to the sqft case, the shift is different for each bedroom 
level, but it's not as significant as the shift in the sqft case. Thus, an interaction 
term may help to improve performance, but the improvement may not be as significant 
as for predicting sqft.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartments_raw_small, aes(x = log(rent), y = bed_count, fill = bath_count)) +
  geom_density_ridges_gradient()
```

### Various categorical predictors

#### Parking

Interestingly, the type of parking does not seem to help predict the size of the 
apartment units. In all 4 graphs, the distribution of both cases essentially overlaps. 

```{r message=FALSE, error=FALSE, warning=FALSE}
parking.sqft <- ggplot(apartments_raw_small, 
                       aes(group=has.parking, fill=has.parking, x = log(sqft))) +
  geom_density(adjust=1.5, alpha=.4)
street.sqft <- ggplot(apartments_raw_small, 
                      aes(group=has.street, fill=has.street, x = log(sqft))) +
  geom_density(adjust=1.5, alpha=.4)
garage.sqft <- ggplot(apartments_raw_small, 
                      aes(group=has.garage, fill=has.garage, x = log(sqft))) +
  geom_density(adjust=1.5, alpha=.4)
lot.sqft <- ggplot(apartments_raw_small, 
                   aes(group=has.lot, fill=has.lot, x = log(sqft))) +
  geom_density(adjust=1.5, alpha=.4)
grid.arrange(parking.sqft, street.sqft, garage.sqft, lot.sqft)
```

On the other hand, the presence of parking would suggests a higher rent, which seems 
to be intuitive. Then, of the different parking types, the presence of a garage parking 
correlate to higher rent. The presence of a street parking suggests a lower rent than 
other apartments. The lot parking seems to be the generic type that doesn't shift the 
distribution much. In this case, the type of parking may contain information about the 
community that the apartment complex is located in. The ones with garage parking may 
indicate a sort of gated community where the street parking may suggest the opposite.

```{r message=FALSE, error=FALSE, warning=FALSE}
parking.rent <- ggplot(apartments_raw_small, 
                       aes(group=has.parking, fill=has.parking, x = log(rent))) +
  geom_density(adjust=1.5, alpha=.4)
street.rent <- ggplot(apartments_raw_small, 
                      aes(group=has.street, fill=has.street, x = log(rent))) +
  geom_density(adjust=1.5, alpha=.4)
garage.rent <- ggplot(apartments_raw_small, 
                      aes(group=has.garage, fill=has.garage, x = log(rent))) +
  geom_density(adjust=1.5, alpha=.4)
lot.rent <- ggplot(apartments_raw_small, 
                   aes(group=has.lot, fill=has.lot, x = log(rent))) +
  geom_density(adjust=1.5, alpha=.4)
grid.arrange(parking.rent, street.rent, garage.rent, lot.rent)
```

### Pet Policies

The sqft vs pet policies and rent vs pet policies present some sort of opposition 
with each other. It seems that allowing pet correlate with smaller apartments, while 
banning pet correlate to bigger apartments. However, the opposite is true regarding 
the rent. On the other hand, negotiable or unknown policies correlate to the same pattern of 
apartment size and rent.

```{r message=FALSE, error=FALSE, warning=FALSE}
pet.sqft <- ggplot(apartments_raw_small, aes(x=pet.allowed, y = log(sqft))) +
  geom_boxplot()
pet.rent <- ggplot(apartments_raw_small, aes(x=pet.allowed, y = log(rent))) +
  geom_boxplot()
grid.arrange(pet.sqft, pet.rent, ncol=2)
```

### Activities

There are minor difference between different level of traffic or business compared to 
sqft. It seems that busier traffic nearby correlate to smaller apartments, while 
active but not busy business correlate to larger apartments. In fact, the active business 
apartments seems to have similar distribution with the calm apartments. In this case, 
the level of activities may have captured some geo-location information regarding the 
apartments. The busier ones may be located near the developed portion of the city, which 
may not support larger apartments.

```{r message=FALSE, error=FALSE, warning=FALSE}
traffic.plot <- ggplot(apartments_raw_small, aes(x=traffic.level, y = log(sqft))) +
  geom_boxplot()
busi.plot <- ggplot(apartments_raw_small, aes(x=busi.level, y = log(sqft))) +
  geom_boxplot()
grid.arrange(traffic.plot, busi.plot, ncol=2)
```

The opposite pattern holds for rent. In general, the busier the area is, the higher the 
rent. This also seems to suggest the information of activity level correspond to the location 
of the apartment in the city.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartments_raw_small, aes(x=traffic.level, y = log(rent))) +
  geom_boxplot()
ggplot(apartments_raw_small, aes(x=busi.level, y = log(rent))) +
  geom_boxplot()
```

### Shopping Centers

There is a positive correlation between the rent and number of shopping center. 
However, the increase per shopping center is small, and the linear function was able 
to approximate the center of the distribution. The exact opposite can be said with 
respect to sqft. Similar to activity level, besides being a service themselves, 
shopping center may also be related to location information.

```{r message=FALSE, error=FALSE, warning=FALSE}
coefs.rent.shop <- coef(lm(log(rent) ~ shopping.num, data = apartments_raw_small))
coefs.sqft.shop <- coef(lm(log(sqft) ~ shopping.num, data = apartments_raw_small))

shop.rent.plt <- ggplot(apartments_raw_small, 
                        aes(x=shopping.num, group=shopping.num, y = log(rent))) +
                        geom_boxplot() +
                        geom_abline(intercept = coefs.rent.shop[1], 
                                    slope = coefs.rent.shop[2],
                                    color="red", alpha=0.5)
shop.sqft.plt <- ggplot(apartments_raw_small, 
                        aes(x=shopping.num, group=shopping.num, y = log(sqft))) +
                        geom_boxplot() +
                        geom_abline(intercept = coefs.sqft.shop[1], 
                                    slope = coefs.sqft.shop[2],
                                    color="red", alpha=0.5)
```

### Geo-information

The density plot of the apartments shows that there are three hubs of apartments. 
The two most popular hub are in center east, and north east of the city. The third 
hub of apartments is in the south east of the city, and it's not as concentrated 
as the hubs in the north. The rest of the apartments are more or less evenly distributed 
throughout the city.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartments_raw_small, aes(x=lng, y=lat)) + geom_bin2d(bins = 70) +
  scale_fill_continuous(type = "viridis") + xlim(-88, -87.35) + ylim(41.56, 42.06)
```

The rent correspond to the hubs of apartment locations. The rent is higher in the 
two hubs in the north and small cluster in the south. The lowest rent is concentrated 
in the south of the city. However, since the rent is clustered by area, it may present a 
issue for a linear estimator. From the south to the north, the rent increased, then decreased, 
then increased again, and finally decreased at the northern most of the city. The high 
rent area is concentrated in the east, but the rest of the areas seems to be fairly 
flat in terms of rent. Thus, there's no clear linear pattern. However, the location 
information is also captured by the zip code as well as neighborhood, which would work 
better for pockets of apartments. Additionally, it may be possible to reparametrize 
from the center of the city by radius and angle. That way, there may be a more consistent 
pattern in the rent.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartment_geo_rounded <- data.frame(apartments_raw_small)
apartment_geo_rounded$lat <- round(apartment_geo_rounded$lat, 2)
apartment_geo_rounded$lng <- round(apartment_geo_rounded$lng, 2)
ggplot(apartment_geo_rounded, aes(x=lng, y=lat, fill=rent)) + geom_tile() +
  xlim(-88, -87.35) + ylim(41.56, 42.06) + 
  scale_fill_viridis(trans = "log")
```
Similar statement regarding linear pattern can be said for the sqft as well. The sqft 
distribution is fairly flat in most places. However, in general, the west of the city seems 
to have larger apartments than the eastern side.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartment_geo_rounded[!is.na(apartments_raw_small$sqft), ], aes(x=lng, y=lat, fill=sqft)) + 
  geom_tile() + xlim(-88, -87.35) + ylim(41.56, 42.06) +
  scale_fill_viridis(trans = "log")
```

It seems that the business level and shopping numbers indeed relates to the geographical location 
of the apartments. The busy areas with 3 shopping centers are located in the center 
hubs of the apartments, while the less busy areas are in the surrounding regions. 
The shopping centers are more spread throughout the city.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartment_geo_rounded, aes(x=lng, y=lat, fill=busi.level)) + 
  geom_tile() + xlim(-88, -87.35) + ylim(41.56, 42.06)
ggplot(apartment_geo_rounded, aes(x=lng, y=lat, fill=shopping.num)) + 
  geom_tile() + xlim(-88, -87.35) + ylim(41.56, 42.06)
```

### Environment Scores

A pairwise plot of the environment scores is shown below. Both the graphs and correlation 
coefficients suggest that the scores are associated with each other. In general, 
the scores regarding transportation are positively correlated with each other. The 
sound score is negatively correlated with the transportation scores. From the graph 
regarding business levels, the geographical location may play a role in the correlations 
here. 

```{r message=FALSE, error=FALSE, warning=FALSE}
ggpairs(apartments_raw_small[, c("walk.score", "bike.score", "sound.score", "transit.score")], 
        title="Environmment Scores") 
```

PCA is applied to the scores in order to remove the multi-colinearity, and to potentially 
reduce the dimension needed for the prediction. The result shows that the first 2 PCs 
captured almost 90% of the variations in the data. The projection of the variable vectors 
into the PC vector space also showed the association between the transportation related 
scores and sound score as indicated before.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartment.sqft.drop <- apartments_raw_small[!is.na(apartments_raw_small$sqft), ]
score.pcs <- prcomp(apartment.sqft.drop[, c("walk.score", "bike.score", 
                                            "sound.score", "transit.score")]
                    , scale = TRUE)
fviz_eig(score.pcs, addlabels=TRUE)
fviz_pca_var(score.pcs)
score.pcs.dat <- data.frame(score.pcs$x)
score.pcs.dat$log.sqft <- log(apartment.sqft.drop$sqft)
score.pcs.dat$log.rent <- log(apartment.sqft.drop$rent)
```

The correlation between the PCs and the target variables are computed. The coefficients 
suggest that the PCs from the environment scores are not very useful in predicting 
the sqft. However, the sqft as well as PC1 may be useful in predicting the rent.

```{r message=FALSE, error=FALSE, warning=FALSE}
cor(score.pcs.dat)[, 5:6]
```

The pairwise plot of the first two PCs and sqft shows that there is indeed not much 
relation between the environment score and the size of the apartment.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggpairs(
  score.pcs.dat,
  title = "Pairwise PC Plot",
  columns = c(1, 2, 5),
)
```

The PC1 and log(sqft) does indeed show a positive relation with the log(rent). In particular, 
the log(sqft) seems to fit a linear pattern decently, with the points being evenly spread 
on either side of the line throughout. However, the PC1 plot shows somme non-linearity, 
with the smaller PCs all above the line, and the larger PCs clustered around in a bulk.

```{r message=FALSE, error=FALSE, warning=FALSE}
pc1.plt <- ggplot(score.pcs.dat, aes(x=PC1, y=log.rent)) + geom_point() + 
  geom_smooth(method=lm , color="red")
sqft.plt <- ggplot(score.pcs.dat, aes(x=log.sqft, y=log.rent)) + geom_point() + 
  geom_smooth(method=lm , color="red")
pc1.plt
sqft.plt
```

# Predicting Sqft

Since a notable amount of data are missing the sqft field, the field can be filled in 
by trying to predict the sqft from the other attributes. In this case, the model would 
be LASSO regression, which is least squared linear model with 1-norm regularization. 
However, before the model can be fitted, the data need to be scaled and transformed 
to make sure that they are on the same unit, with the considered transformations applied. 
Thus, a few helper functions are created.

```{r message=FALSE, error=FALSE, warning=FALSE}
scale_by <- function(src_col, scale_col, logged=F, inc=0) {
  if(logged) {
    scale_col <- log(scale_col + inc)
    src_col <- log(src_col + inc)
  }
  center <- mean(scale_col)
  scale <- sd(scale_col)
  return((src_col - center) / scale)
}

create_score <- function(og, train_idx) {
  df <- data.frame(og)
  df[, c("PC1", "PC2", "PC3", "PC4")] <- 0
  score.pca <- prcomp(df[train_idx, c("walk.score", "bike.score", 
                             "sound.score", "transit.score")], scale = TRUE)
  score.pca.test <- predict(score.pca, og[-train_idx, ])
  df[train_idx, c("PC1", "PC2", "PC3", "PC4")] <- score.pca$x
  df[-train_idx, c("PC1", "PC2", "PC3", "PC4")] <- score.pca.test
  df <- df[, -which(names(df) %in% 
              c("walk.score", "bike.score", "sound.score", "transit.score"))]
  return(df)
}

scale_apartment <- function(og, train) {
  df <- data.frame(og)
  
  df$beds <- scale_by(df$beds, train$beds)
  df$baths <- scale_by(df$baths, train$baths, T, 1)
  
  df$PC1 <- scale_by(df$PC1, train$PC1)
  df$PC2 <- scale_by(df$PC2, train$PC2)
  df$PC3 <- scale_by(df$PC3, train$PC3)
  df$PC4 <- scale_by(df$PC4, train$PC4)
  
  df$shopping.num <- scale_by(df$shopping.num, train$shopping.num, T, 1)
  df$lat <- scale_by(df$lat, train$lat)
  df$lng <- scale_by(df$lng, train$lng)
  
  df$pet.deposit <- scale_by(df$pet.deposit, train$pet.deposit)
  df$pet.rent <- scale_by(df$pet.rent, train$pet.rent)
  df$pet.fee <- scale_by(df$pet.fee, train$pet.fee)
  df$garage.fee <- scale_by(df$garage.fee, train$garage.fee)
  df$lot.fee <- scale_by(df$lot.fee, train$lot.fee)
  df$covered.fee <- scale_by(df$covered.fee, train$covered.fee)
  
  return(df)
}
```

Then, the data is broken into training and testing set. The scaling and transformation 
are computed from the training set first, then applied to both the training and testing 
set to ensure no leakage. Finally, the variables for the models are entered based 
on the observations in the EDA phase. In this case, since the apartments have limited 
number of bedrooms and bathrooms, both the numerical version and categorical version 
are entered. The 1-norm regularization can set them to 0 if not needed. If they are not 
set to 0, then it is equivalent to having a correction term to the linear trend for 
the bathrooms and bedrooms, so the non-linearity in the data can potentially be taken 
into account.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartment_sqft <- apartments_raw_small[!is.na(apartments_raw_small$sqft), 
                  -which(names(apartments_raw_small) %in% 
                  c("name", "address", "state", "city", "rent"))]

train.control <- trainControl(method = "cv", number = 10)
sqft_train_size <- floor(0.75 * nrow(apartment_sqft))
sqft_train_ind <- sample(seq_len(nrow(apartment_sqft)), size = sqft_train_size)
apartment_sqft <- create_score(apartment_sqft, sqft_train_ind)
apartment_sqft_scaled <- data.frame(apartment_sqft)

apartment_sqft_scaled[sqft_train_ind, ] <- scale_apartment(apartment_sqft[sqft_train_ind, ], 
                                           apartment_sqft[sqft_train_ind, ])
apartment_sqft_scaled[-sqft_train_ind, ] <- scale_apartment(apartment_sqft[-sqft_train_ind, ],
                                            apartment_sqft[sqft_train_ind, ])

lasso_sqft <- model.matrix(log(sqft)~. + bed_count:bath_count + beds:bath_count + 
                             traffic.level:busi.level + bed_count:zip + bath_count:zip +
                             beds:zip + baths:zip + bed_count:neighborhood + 
                             bath_count:neighborhood + beds:neighborhood + 
                             baths:neighborhood + lat:lng + lng:beds + lng:baths, 
                           apartment_sqft_scaled)[, -1]
lasso_sqft <- as.data.frame(lasso_sqft)

sqft_train <- lasso_sqft[sqft_train_ind, ]
sqft_train_target <- log(apartment_sqft_scaled[sqft_train_ind, "sqft"])
sqft_test <- lasso_sqft[-sqft_train_ind, ]
sqft_test_target <- log(apartment_sqft_scaled[-sqft_train_ind, "sqft"])
sqft_train <- as.matrix(sqft_train)
sqft_test <- as.matrix(sqft_test)
```

The LASSO model is fitted, with the hyperparameter lambda chosen via 10-fold 
cross validation. The lambda corresponding to the minimum loss is selected.

```{r message=FALSE, error=FALSE, warning=FALSE}
cv.lasso.sqft <- cv.glmnet(sqft_train, sqft_train_target, nfolds = 10)
plot(cv.lasso.sqft)
sqft.coef <- coef(cv.lasso.sqft, s = 'lambda.min')
sqft.coef <- as.data.frame(sqft.coef[sqft.coef[,1]!= 0, ])
```

The training error is given below in the order of RMSE and MAD. 

```{r message=FALSE, error=FALSE, warning=FALSE}
sqft.train.predict <- predict(cv.lasso.sqft, sqft_train, s = "lambda.min")
sqft.MSE <- sum((exp(sqft.train.predict) - exp(sqft_train_target))^2)
sqft.MSE <- sqft.MSE / length(sqft_train_target)
sqrt(sqft.MSE)
mean(abs(exp(sqft.train.predict) - exp(sqft_train_target)))
```

The testing error is given below in the order of RMSE and MAD as well. The testing error 
is only slightly above the training error, which suggest that the model did not overfit 
to the data, and potentially could be underfitted to the data.

```{r message=FALSE, error=FALSE, warning=FALSE}
sqft.test.predict <- predict(cv.lasso.sqft, sqft_test, s = "lambda.min")
sqft.MSE <- sum((exp(sqft.test.predict) - exp(sqft_test_target))^2)
sqft.MSE <- sqft.MSE / length(sqft_test_target)
sqrt(sqft.MSE)
mean(abs(exp(sqft.test.predict) - exp(sqft_test_target)))
```

The training and testing residuals are plotted below. In either case, the model fitted 
better to the smaller apartments than the bigger ones. For the large sized apartments, 
the model is consistently under-estimating the size. Furthermore, as the apartments get 
larger, the difference becomes greater, which suggests that there's non-linearity in the data 
still remaining after the log transformations.

```{r message=FALSE, error=FALSE, warning=FALSE}
sqft.resid.train <- data.frame(exp(sqft_train_target), 
                               (exp(sqft.train.predict) - exp(sqft_train_target)))
sqft.resid.test <- data.frame(exp(sqft_test_target), 
                              (exp(sqft.test.predict) - exp(sqft_test_target)))
colnames(sqft.resid.test) <- c("sqft", "residual")
colnames(sqft.resid.train) <- c("sqft", "residual")
sqft.train.plot <- ggplot(sqft.resid.train, aes(x=sqft, y=residual)) + geom_point() +
  geom_abline(slope=0, color="red")
sqft.test.plot <- ggplot(sqft.resid.test, aes(x=sqft, y=residual)) + geom_point() + 
  geom_abline(slope=0, color="red")
grid.arrange(sqft.train.plot, sqft.test.plot)
```

The model is then trained on the full dataset using the hyperparameter found during 
the cross validation, with the same variable selection. Furthermore, since the model 
was making consistent error for the larger apartments, an extra variable sqft.regressed 
is added to indicate which sqft is estimated. Thus, for downstream predictions, the error 
may be taken into account.

```{r message=FALSE, error=FALSE, warning=FALSE}
apartments_raw_small$sqft.regressed <- is.na(apartments_raw_small$sqft)
apartments_raw_small[apartments_raw_small$sqft.regressed, "sqft"] <- -1
apartment.composite <- create_score(apartments_raw_small, rep(T, nrow(apartments_raw_small)))
sqft.fill.scaled <- scale_apartment(apartment.composite[, 
                  -which(names(apartment.composite) %in% 
                  c("name", "address", "state", "city", "rent", "sqft.regressed"))], 
                  apartment.composite)

apartment.fillsqft <- model.matrix(sqft~. + bed_count:bath_count + beds:bath_count + 
                             traffic.level:busi.level + bed_count:zip + bath_count:zip +
                             beds:zip + baths:zip + bed_count:neighborhood + 
                             bath_count:neighborhood + beds:neighborhood + 
                             baths:neighborhood + lat:lng + lng:beds + lng:baths, 
                           sqft.fill.scaled)[, -1]
sqft.target <- log(sqft.fill.scaled[!apartments_raw_small$sqft.regressed, "sqft"])
sqft.train <- apartment.fillsqft[!apartments_raw_small$sqft.regressed, ]
full.lasso.sqft <- glmnet(sqft.train, sqft.target, 
                          lambda=cv.lasso.sqft$lambda.min)
save(full.lasso.sqft, file="sqft.mod.RData")
```

The RMSE and MAD on the whole dataset is given below. It is similar to the error 
on the training set.

```{r message=FALSE, error=FALSE, warning=FALSE}
sqft.full.predict <- predict(full.lasso.sqft, sqft.train)
sqft.full.MSE <- sum((exp(sqft.full.predict) - exp(sqft.target))^2)
sqft.full.MSE <- sqft.full.MSE / length(sqft.target)
sqrt(sqft.full.MSE)
mean(abs(exp(sqft.full.predict) - exp(sqft.target)))
```

The missing sqft is filled in using the sqft calculated on the model. It is a form 
of interpolation since it's the same dataset.

```{r message=FALSE, error=FALSE, warning=FALSE}
filled_sqft <- predict(full.lasso.sqft, apartment.fillsqft[apartments_raw_small$sqft.regressed, ])
apartments_raw_small[apartments_raw_small$sqft.regressed, "sqft"] <- exp(filled_sqft)
```

The distribution of the log(rent) is plotted against sqft.regressed. It shows that 
the apartments with provided sqft has a slightly higher rent then the apartments with 
regressed sqft in general.

```{r message=FALSE, error=FALSE, warning=FALSE}
ggplot(apartments_raw_small, aes(group=sqft.regressed, fill=sqft.regressed, x = log(rent))) +
  geom_density(adjust=1.5, alpha=.4)
```

## The pricing model

To create the full pricing model, the sqft needs to be taken into account. Thus, 
the helper functions from earlier are modified to incorporate log(sqft). Furthermore, 
the data is divided again into training set and testing set as before, and the variables 
are selected based on prior observations, and the fact that LASSO will be used.

```{r message=FALSE, error=FALSE, warning=FALSE}
scale_apartment <- function(og, train) {
  df <- as.data.frame(og)
  df <- data.frame(og)
  
  df$beds <- scale_by(df$beds, train$beds)
  df$baths <- scale_by(df$baths, train$baths, T, 1)
  
  df$PC1 <- scale_by(df$PC1, train$PC1)
  df$PC2 <- scale_by(df$PC2, train$PC2)
  df$PC3 <- scale_by(df$PC3, train$PC3)
  df$PC4 <- scale_by(df$PC4, train$PC4)
  
  df$shopping.num <- scale_by(df$shopping.num, train$shopping.num, T, 1)
  df$lat <- scale_by(df$lat, train$lat)
  df$lng <- scale_by(df$lng, train$lng)
  
  df$pet.deposit <- scale_by(df$pet.deposit, train$pet.deposit)
  df$pet.rent <- scale_by(df$pet.rent, train$pet.rent)
  df$pet.fee <- scale_by(df$pet.fee, train$pet.fee)
  df$garage.fee <- scale_by(df$garage.fee, train$garage.fee)
  df$lot.fee <- scale_by(df$lot.fee, train$lot.fee)
  df$covered.fee <- scale_by(df$covered.fee, train$covered.fee)
  df$sqft <- scale_by(df$sqft, train$sqft, T)
  return(df)
}

apartment_rent <- apartments_raw_small[, -which(names(apartments_raw_small) %in% 
                  c("name", "address", "state", "city"))]
rent_train_size <- floor(0.75 * nrow(apartment_rent))
rent_train_ind <- sample(seq_len(nrow(apartment_rent)), size = rent_train_size)
apartment_rent <- create_score(apartment_rent, rent_train_ind)

apartment_rent.scaled <- data.frame(apartment_rent)
apartment_rent.scaled[rent_train_ind, ] <- scale_apartment(apartment_rent[rent_train_ind, ],
                                                           apartment_rent[rent_train_ind, ])
apartment_rent.scaled[-rent_train_ind, ] <- scale_apartment(apartment_rent[-rent_train_ind, ],
                                                           apartment_rent[rent_train_ind, ])

lasso_rent <- model.matrix(log(rent)~. + bed_count:bath_count + beds:bath_count + 
                             traffic.level:busi.level + bed_count:zip + bath_count:zip +
                             beds:zip + baths:zip + bed_count:neighborhood + 
                             bath_count:neighborhood + beds:neighborhood + 
                             baths:neighborhood + sqft:beds + sqft:baths +
                             sqft:zip + sqft:neighborhood + sqft:sqft.regressed +
                             lat:lng + lat:zip, 
                           apartment_rent.scaled)[, -1]
lasso_rent <- as.data.frame(lasso_rent)

rent_train <- lasso_rent[rent_train_ind, ]
rent_train_target <- log(apartment_rent[rent_train_ind, "rent"])
rent_test <- lasso_rent[-rent_train_ind, ]
rent_test_target <- log(apartment_rent[-rent_train_ind, "rent"])
rent_train <- as.matrix(rent_train)
rent_test <- as.matrix(rent_test)
```

Similar to previously, the hyperparameter is chosen via cross validation. The lambda 
that minimizes the MSE is selected.

```{r message=FALSE, error=FALSE, warning=FALSE}
cv.lasso.rent <- cv.glmnet(rent_train, rent_train_target, nfolds = 10)
plot(cv.lasso.rent)
rent.coef <- coef(cv.lasso.rent, s = 'lambda.min')
rent.coef <- as.data.frame(rent.coef[rent.coef[,1]!= 0, ])
```

The training error is given below in the order of RMSE and MAD.

```{r message=FALSE, error=FALSE, warning=FALSE}
rent.train.predict <- predict(cv.lasso.rent, rent_train, s = "lambda.min")
rent.MSE <- sum((exp(rent.train.predict) - exp(rent_train_target))^2)
rent.MSE <- rent.MSE / length(rent_train_target)
sqrt(rent.MSE)
mean(abs(exp(rent.train.predict) - exp(rent_train_target)))
```

The test error is given below. It is increased from the training error, but not 
by much. Thus, it suggests that the model did not overfit significantly on the training 
set.

```{r message=FALSE, error=FALSE, warning=FALSE}
rent.test.predict <- predict(cv.lasso.rent, rent_test, s = "lambda.min")
rent.MSE <- sum((exp(rent.test.predict) - exp(rent_test_target))^2)
rent.MSE <- rent.MSE / length(rent_test_target)
sqrt(rent.MSE)
mean(abs(exp(rent.test.predict) - exp(rent_test_target)))
```

The residual plots for both the training and test set are shown below. It seems 
that the rent LASSO encountered similar problem with the sqft, that is, the more 
expensive the apartment, the greater the error. Furthermore, for the expensive apartments, 
the LASSO regression consistently under-predicted the rent, similar to the sqft case. 
Thus, it suggests that there are non-linearities not handled by the log transformation. 

```{r message=FALSE, error=FALSE, warning=FALSE}
rent.resid.train <- data.frame(exp(rent_train_target), 
                               (exp(rent.train.predict) - exp(rent_train_target)))
rent.resid.test <- data.frame(exp(rent_test_target), 
                              (exp(rent.test.predict) - exp(rent_test_target)))
colnames(rent.resid.test) <- c("rent", "residual")
colnames(rent.resid.train) <- c("rent", "residual")
rent.train.plot <- ggplot(rent.resid.train, aes(x=rent, y=residual)) + geom_point() + 
  geom_abline(slope=0, color="red")
rent.test.plot <- ggplot(rent.resid.test, aes(x=rent, y=residual)) + geom_point() + 
  geom_abline(slope=0, color="red")
grid.arrange(rent.train.plot, rent.test.plot)
```

The LASSO model is fitted on the full dataset with the same hyperparameter and variables. 
The RMSE and MAD is given below. The error is similar to the error achieved on the 
training set previously.

```{r message=FALSE, error=FALSE, warning=FALSE}
lasso_target.full <- log(apartment_rent$rent)
apartment_rent <- apartments_raw_small[, -which(names(apartments_raw_small) %in% 
                  c("name", "address", "state", "city"))]
apartment_rent <- create_score(apartment_rent, rep(T, nrow(apartment_rent)))
lasso_rent_scaled <- as.data.frame(apartment_rent)
lasso_rent_scaled <- scale_apartment(lasso_rent_scaled, lasso_rent_scaled)
lasso_rent.full <- model.matrix(log(rent)~. + bed_count:bath_count + beds:bath_count + 
                             traffic.level:busi.level + bed_count:zip + bath_count:zip +
                             beds:zip + baths:zip + bed_count:neighborhood + 
                             bath_count:neighborhood + beds:neighborhood + 
                             baths:neighborhood + sqft:beds + sqft:baths +
                             sqft:zip + sqft:neighborhood + sqft:sqft.regressed +
                             lat:lng + lat:zip, 
                           lasso_rent_scaled)[, -1]
full_lasso_mod <- glmnet(lasso_rent.full, lasso_target.full, lambda=cv.lasso.rent$lambda.min)
save(full_lasso_mod, file="rent.mod.RData")
rent.full.predict <- exp(predict(full_lasso_mod, lasso_rent.full))
rent.full.MSE <- sum((rent.full.predict - exp(lasso_target.full))^2)
rent.full.MSE <- rent.full.MSE / length(lasso_target.full)
RMSE <- sqrt(rent.full.MSE)
MAD <- mean(abs(rent.full.predict - exp(lasso_target.full)))

RMSE
MAD
```

The residual plot on the full dataset is given below. The same pattern persist from 
the training/testing residual plot.

```{r message=FALSE, error=FALSE, warning=FALSE}
lasso.resid.full <- data.frame(exp(lasso_target.full), 
                               (rent.full.predict - exp(lasso_target.full)))
colnames(lasso.resid.full) <- c("rent", "residual")
ggplot(lasso.resid.full, aes(x=rent, y=residual)) + geom_point() + 
  geom_abline(slope=0, color="red")
```

If the model is only applied to less expensive apartments with <= $3000 rent, then 
the RMSE and MAD are smaller than the full dataset, which also suggests that the 
more expensive apartments present a problem to the model.

```{r message=FALSE, error=FALSE, warning=FALSE}
predict.idx <- apartment_rent$rent <= 3000
rent.limit.predict <- rent.full.predict[predict.idx]
lasso_target.limit <- lasso_target.full[predict.idx]
rent.limit.MSE <- sum((rent.limit.predict - exp(lasso_target.limit))^2)
rent.limit.MSE <- rent.limit.MSE / length(lasso_target.limit)
RMSE <- sqrt(rent.limit.MSE)
MAD <- mean(abs(rent.limit.predict - exp(lasso_target.limit)))

RMSE
MAD
```

The residual plot for apartments under $3000 is shown below. In this case, there 
are not obvious pattern of non-linearity near the $3000 range. However, there seems to 
be a trend of over-estimating the rent for less-expensive apartments at around $1000 
range, thus there are some non-linearity in the cheap apartments as well. This 
trend manifested earlier when only looking the log(rent) vs beds, where the linear 
function also over-predicted the center of the log(rent) distribution. Furthermore, 
as the apartments get closer to the $3000 range, the variance of the residual increased, so 
the model performance is worse the more expensive the apartments get.

```{r message=FALSE, error=FALSE, warning=FALSE}
lasso.resid.limit <- data.frame(exp(lasso_target.limit), 
                                (rent.limit.predict - exp(lasso_target.limit)))
colnames(lasso.resid.limit) <- c("rent", "residual")
ggplot(lasso.resid.limit, aes(x=rent, y=residual)) + geom_point() + 
  geom_abline(slope=0, color="red")
```

# Discussion

It is clear that the LASSO model with the selected variables does not fit well 
to the dataset. Even with the log transformation applied, it was not able to address 
the non-linearity in the data. Additionally, as the apartments become more expensive, 
there are more variations in the price of the apartments. Currently, those variations 
are not taken account of by the linear model. However, since the full dataset has more 
variables, including various amenities and the exact name of the schools nearby, a 
model trained on the full dataset may better address the increase in variations. For 
the non-linearity, a different class of models that has more flexibility can be trained. 
For instance, a SVR with a kernel may be able to fit more varieties of non-linear function, 
and also to feasibly address the interactions with almost 50 variables in the dataset. Furthermore, 
since there are almost 17k data points, a neural network may be able to fit an even larger 
class of functions without over-fitting.

For the purpose of pricing the apartments, the model could still provide a guideline for 
the less expensive apartments under $3000. For this subset of the data, the prediction 
sits closer to the center of distribution of the apartments. Thus, the apartment price 
could be normalized with respect to the apartment market and their peers by calculating 
a score such as:

$$Score = (ApartmentPrice - ModelPrice) / (MAD)$$

It would be able to give the potential renter a sense of how their apartment is priced 
with respect to the distribution of similar apartments.


